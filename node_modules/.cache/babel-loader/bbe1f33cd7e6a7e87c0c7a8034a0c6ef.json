{"ast":null,"code":"import _get from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { LineBasicMaterial, Box3Helper, Box3, Group, LineSegments } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nvar wiremat = new LineBasicMaterial({\n  color: 0x00FF88,\n  transparent: true,\n  opacity: 0.3\n});\nvar boxGeom = new Box3Helper().geometry;\nvar boundingBox = new Box3();\n\nvar MeshBVHRootVisualizer = /*#__PURE__*/function (_Group) {\n  _inherits(MeshBVHRootVisualizer, _Group);\n\n  var _super = _createSuper(MeshBVHRootVisualizer);\n\n  function MeshBVHRootVisualizer(mesh) {\n    var _this;\n\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var group = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, MeshBVHRootVisualizer);\n\n    _this = _super.call(this, 'MeshBVHRootVisualizer');\n    _this.depth = depth;\n    _this.mesh = mesh;\n    _this._group = group;\n\n    _this.update();\n\n    return _this;\n  }\n\n  _createClass(MeshBVHRootVisualizer, [{\n    key: \"update\",\n    value: function update() {\n      var _this2 = this;\n\n      var boundsTree = this.mesh.geometry.boundsTree;\n      var requiredChildren = 0;\n\n      if (boundsTree) {\n        boundsTree.traverse(function (depth, isLeaf, boundingData, offsetOrSplit, countOrIsUnfinished) {\n          var isTerminal = isLeaf || countOrIsUnfinished; // Stop traversal\n\n          if (depth >= _this2.depth) {\n            return true;\n          }\n\n          if (depth === _this2.depth - 1 || isTerminal) {\n            var m = requiredChildren < _this2.children.length ? _this2.children[requiredChildren] : null;\n\n            if (!m) {\n              m = new LineSegments(boxGeom, wiremat);\n\n              m.raycast = function () {\n                return [];\n              };\n\n              _this2.add(m);\n            }\n\n            requiredChildren++;\n            arrayToBox(boundingData, boundingBox);\n            boundingBox.getCenter(m.position);\n            m.scale.subVectors(boundingBox.max, boundingBox.min).multiplyScalar(0.5);\n            if (m.scale.x === 0) m.scale.x = Number.EPSILON;\n            if (m.scale.y === 0) m.scale.y = Number.EPSILON;\n            if (m.scale.z === 0) m.scale.z = Number.EPSILON;\n          }\n        });\n      }\n\n      while (this.children.length > requiredChildren) {\n        this.remove(this.children.pop());\n      }\n    }\n  }]);\n\n  return MeshBVHRootVisualizer;\n}(Group);\n\nvar MeshBVHVisualizer = /*#__PURE__*/function (_Group2) {\n  _inherits(MeshBVHVisualizer, _Group2);\n\n  var _super2 = _createSuper(MeshBVHVisualizer);\n\n  function MeshBVHVisualizer(mesh) {\n    var _this3;\n\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, MeshBVHVisualizer);\n\n    _this3 = _super2.call(this, 'MeshBVHVisualizer');\n    _this3.depth = depth;\n    _this3.mesh = mesh;\n    _this3._roots = [];\n\n    _this3.update();\n\n    return _this3;\n  }\n\n  _createClass(MeshBVHVisualizer, [{\n    key: \"update\",\n    value: function update() {\n      var bvh = this.mesh.geometry.boundsTree;\n      var totalRoots = bvh ? bvh._roots.length : 0;\n\n      while (this._roots.length > totalRoots) {\n        this._roots.pop();\n      }\n\n      for (var i = 0; i < totalRoots; i++) {\n        if (i >= this._roots.length) {\n          var root = new MeshBVHRootVisualizer(this.mesh, this.depth, i);\n          this.add(root);\n\n          this._roots.push(root);\n        } else {\n          var _root = this._roots[i];\n          _root.depth = this.depth;\n          _root.mesh = this.mesh;\n\n          _root.update();\n        }\n      }\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld() {\n      var _get2;\n\n      this.position.copy(this.mesh.position);\n      this.rotation.copy(this.mesh.rotation);\n      this.scale.copy(this.mesh.scale);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_get2 = _get(_getPrototypeOf(MeshBVHVisualizer.prototype), \"updateMatrixWorld\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.depth = source.depth;\n      this.mesh = source.mesh;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new MeshBVHVisualizer(this.mesh, this.depth);\n    }\n  }]);\n\n  return MeshBVHVisualizer;\n}(Group);\n\nexport default MeshBVHVisualizer;","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/MeshBVHVisualizer.js"],"names":["LineBasicMaterial","Box3Helper","Box3","Group","LineSegments","arrayToBox","wiremat","color","transparent","opacity","boxGeom","geometry","boundingBox","MeshBVHRootVisualizer","mesh","depth","group","_group","update","boundsTree","requiredChildren","traverse","isLeaf","boundingData","offsetOrSplit","countOrIsUnfinished","isTerminal","m","children","length","raycast","add","getCenter","position","scale","subVectors","max","min","multiplyScalar","x","Number","EPSILON","y","z","remove","pop","MeshBVHVisualizer","_roots","bvh","totalRoots","i","root","push","copy","rotation","args","source"],"mappings":"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","sourcesContent":["import { LineBasicMaterial, Box3Helper, Box3, Group, LineSegments } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\n\r\nconst wiremat = new LineBasicMaterial( { color: 0x00FF88, transparent: true, opacity: 0.3 } );\r\nconst boxGeom = new Box3Helper().geometry;\r\nlet boundingBox = new Box3();\r\n\r\nclass MeshBVHRootVisualizer extends Group {\r\n\r\n\tconstructor( mesh, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper( 'MeshBVHRootVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis._group = group;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tlet requiredChildren = 0;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, countOrIsUnfinished ) => {\r\n\r\n\t\t\t\tlet isTerminal = isLeaf || countOrIsUnfinished;\r\n\r\n\t\t\t\t// Stop traversal\r\n\t\t\t\tif ( depth >= this.depth ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( depth === this.depth - 1 || isTerminal ) {\r\n\r\n\t\t\t\t\tlet m = requiredChildren < this.children.length ? this.children[ requiredChildren ] : null;\r\n\t\t\t\t\tif ( ! m ) {\r\n\r\n\t\t\t\t\t\tm = new LineSegments( boxGeom, wiremat );\r\n\t\t\t\t\t\tm.raycast = () => [];\r\n\t\t\t\t\t\tthis.add( m );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trequiredChildren ++;\r\n\t\t\t\t\tarrayToBox( boundingData, boundingBox );\r\n\t\t\t\t\tboundingBox.getCenter( m.position );\r\n\t\t\t\t\tm.scale.subVectors( boundingBox.max, boundingBox.min ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\tif ( m.scale.x === 0 ) m.scale.x = Number.EPSILON;\r\n\t\t\t\t\tif ( m.scale.y === 0 ) m.scale.y = Number.EPSILON;\r\n\t\t\t\t\tif ( m.scale.z === 0 ) m.scale.z = Number.EPSILON;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( this.children.length > requiredChildren ) this.remove( this.children.pop() );\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper( 'MeshBVHVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis._roots = [];\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet root = this._roots[ i ];\r\n\t\t\t\troot.depth = this.depth;\r\n\t\t\t\troot.mesh = this.mesh;\r\n\t\t\t\troot.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport default MeshBVHVisualizer;\r\n"]},"metadata":{},"sourceType":"module"}