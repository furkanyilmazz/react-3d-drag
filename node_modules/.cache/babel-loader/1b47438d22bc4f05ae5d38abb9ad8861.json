{"ast":null,"code":"/* Generated from \"castFunctions.template.js\". Do not edit. */\n// For speed and readability this script is processed to replace the macro-like calls\n// with inline buffer reads. See generate-cast-functions.js.\nimport { Box3, Vector3, Mesh, Matrix4 } from 'three';\nimport { intersectTris, intersectClosestTri } from './Utils/RayIntersectTriUtlities.js';\nimport { arrayToBox } from './Utils/BufferNodeUtils.js';\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { CONTAINED } from './Constants.js';\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = ['x', 'y', 'z'];\nexport function raycast(nodeIndex32, mesh, geometry, raycaster, ray, intersects) {\n  let nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  const isLeaf = uint16Array[nodeIndex16 + 15] === 0xFFFF;\n\n  if (isLeaf) {\n    const offset = uint32Array[nodeIndex32 + 6];\n    const count = uint16Array[nodeIndex16 + 14];\n    intersectTris(mesh, geometry, raycaster, ray, offset, count, intersects);\n  } else {\n    const leftIndex = nodeIndex32 + 8;\n\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, mesh, geometry, raycaster, ray, intersects);\n    }\n\n    const rightIndex = uint32Array[nodeIndex32 + 6];\n\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, mesh, geometry, raycaster, ray, intersects);\n    }\n  }\n}\nexport function raycastFirst(nodeIndex32, mesh, geometry, raycaster, ray) {\n  let nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  const isLeaf = uint16Array[nodeIndex16 + 15] === 0xFFFF;\n\n  if (isLeaf) {\n    const offset = uint32Array[nodeIndex32 + 6];\n    const count = uint16Array[nodeIndex16 + 14];\n    return intersectClosestTri(mesh, geometry, raycaster, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    const splitAxis = uint32Array[nodeIndex32 + 7];\n    const xyzAxis = xyzFields[splitAxis];\n    const rayDir = ray.direction[xyzAxis];\n    const leftToRight = rayDir >= 0; // c1 is the child to check first\n\n    let c1, c2;\n\n    if (leftToRight) {\n      c1 = nodeIndex32 + 8;\n      c2 = uint32Array[nodeIndex32 + 6];\n    } else {\n      c1 = uint32Array[nodeIndex32 + 6];\n      c2 = nodeIndex32 + 8;\n    }\n\n    const c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    const c1Result = c1Intersection ? raycastFirst(c1, mesh, geometry, raycaster, ray) : null; // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n\n    if (c1Result) {\n      // check if the point is within the second bounds\n      const point = c1Result.point[xyzAxis];\n      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    } // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n\n\n    const c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    const c2Result = c2Intersection ? raycastFirst(c2, mesh, geometry, raycaster, ray) : null;\n\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nexport const shapecast = function () {\n  const _triangle = new SeparatingAxisTriangle();\n\n  const _cachedBox1 = new Box3();\n\n  const _cachedBox2 = new Box3();\n\n  return function shapecast(nodeIndex32, mesh, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, // offset for unique node identifier\n  depth = 0, triangle = _triangle, cachedBox1 = _cachedBox1, cachedBox2 = _cachedBox2) {\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      let nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!(uint16Array[nodeIndex16 + 15] === 0xFFFF)) {\n        nodeIndex32 = nodeIndex32 + 8;\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      return uint32Array[nodeIndex32 + 6];\n    }\n\n    function getRightEndOffset(nodeIndex32) {\n      let nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!(uint16Array[nodeIndex16 + 15] === 0xFFFF)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = uint32Array[nodeIndex32 + 6];\n        nodeIndex16 = nodeIndex32 * 2;\n      } // return the end offset of the triangle range\n\n\n      return uint32Array[nodeIndex32 + 6] + uint16Array[nodeIndex16 + 14];\n    }\n\n    let nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n    const isLeaf = uint16Array[nodeIndex16 + 15] === 0xFFFF;\n\n    if (isLeaf) {\n      const offset = uint32Array[nodeIndex32 + 6];\n      const count = uint16Array[nodeIndex16 + 14];\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndex32);\n    } else {\n      const left = nodeIndex32 + 8;\n      const right = uint32Array[nodeIndex32 + 6];\n      let c1 = left;\n      let c2 = right;\n      let score1, score2;\n      let box1, box2;\n\n      if (nodeScoreFunc) {\n        box1 = cachedBox1;\n        box2 = cachedBox2; // bounding data is not offset\n\n        arrayToBox(c1, float32Array, box1);\n        arrayToBox(c2, float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          const temp = score1;\n          score1 = score2;\n          score2 = temp;\n          box1 = box2; // box2 is always set before use below\n        }\n      } // Check box 1 intersection\n\n\n      if (!box1) {\n        box1 = cachedBox1;\n        arrayToBox(c1, float32Array, box1);\n      }\n\n      const isC1Leaf = uint16Array[c1 * 2 + 15] === 0xFFFF;\n      const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      let c1StopTraversal;\n\n      if (c1Intersection === CONTAINED) {\n        const offset = getLeftOffset(c1);\n        const end = getRightEndOffset(c1);\n        const count = end - offset;\n        c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecast(c1, mesh, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1, triangle, cachedBox1, cachedBox2);\n      }\n\n      if (c1StopTraversal) return true; // Check box 2 intersection\n      // cached box2 will have been overwritten by previous traversal\n\n      box2 = cachedBox2;\n      arrayToBox(c2, float32Array, box2);\n      const isC2Leaf = uint16Array[c2 * 2 + 15] === 0xFFFF;\n      const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      let c2StopTraversal;\n\n      if (c2Intersection === CONTAINED) {\n        const offset = getLeftOffset(c2);\n        const end = getRightEndOffset(c2);\n        const count = end - offset;\n        c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecast(c2, mesh, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1, triangle, cachedBox1, cachedBox2);\n      }\n\n      if (c2StopTraversal) return true;\n      return false;\n    }\n  };\n}();\nexport const intersectsGeometry = function () {\n  const triangle = new SeparatingAxisTriangle();\n  const triangle2 = new SeparatingAxisTriangle();\n  const cachedMesh = new Mesh();\n  const invertedMat = new Matrix4();\n  const obb = new OrientedBox();\n  const obb2 = new OrientedBox();\n  return function intersectsGeometry(nodeIndex32, mesh, geometry, otherGeometry, geometryToBvh, cachedObb = null) {\n    let nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.update();\n      cachedObb = obb;\n    }\n\n    const isLeaf = uint16Array[nodeIndex16 + 15] === 0xFFFF;\n\n    if (isLeaf) {\n      const thisGeometry = geometry;\n      const thisIndex = thisGeometry.index;\n      const thisPos = thisGeometry.attributes.position;\n      const index = otherGeometry.index;\n      const pos = otherGeometry.attributes.position;\n      const offset = uint32Array[nodeIndex32 + 6];\n      const count = uint16Array[nodeIndex16 + 14]; // get the inverse of the geometry matrix so we can transform our triangles into the\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\n      // here.\n\n      invertedMat.copy(geometryToBvh).invert();\n\n      if (otherGeometry.boundsTree) {\n        arrayToBox(nodeIndex32, float32Array, obb2);\n        obb2.matrix.copy(invertedMat);\n        obb2.update();\n        cachedMesh.geometry = otherGeometry;\n        const res = otherGeometry.boundsTree.shapecast(cachedMesh, {\n          intersectsBounds: box => obb2.intersectsBox(box),\n          intersectsTriangle: tri => {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.update();\n\n            for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              // this triangle needs to be transformed into the current BVH coordinate frame\n              setTriangle(triangle2, i, thisIndex, thisPos);\n              triangle2.update();\n\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n        cachedMesh.geometry = null;\n        return res;\n      } else {\n        for (let i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          // this triangle needs to be transformed into the current BVH coordinate frame\n          setTriangle(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.update();\n\n          for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, index, pos);\n            triangle2.update();\n\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      const left = nodeIndex32 + 8;\n      const right = uint32Array[nodeIndex32 + 6];\n      arrayToBox(left, float32Array, boundingBox);\n      const leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection) return true;\n      arrayToBox(right, float32Array, boundingBox);\n      const rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection) return true;\n      return false;\n    }\n  };\n}();\n\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  arrayToBox(nodeIndex32, array, boundingBox);\n  return ray.intersectBox(boundingBox, target);\n}\n\nconst bufferStack = [];\n\nlet _prevBuffer;\n\nlet _float32Array;\n\nlet _uint16Array;\n\nlet _uint32Array;\n\nexport function setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\nexport function clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/castFunctions.js"],"names":["Box3","Vector3","Mesh","Matrix4","intersectTris","intersectClosestTri","arrayToBox","OrientedBox","setTriangle","SeparatingAxisTriangle","CONTAINED","boundingBox","boxIntersection","xyzFields","raycast","nodeIndex32","mesh","geometry","raycaster","ray","intersects","nodeIndex16","float32Array","_float32Array","uint16Array","_uint16Array","uint32Array","_uint32Array","isLeaf","offset","count","leftIndex","intersectRay","rightIndex","raycastFirst","splitAxis","xyzAxis","rayDir","direction","leftToRight","c1","c2","c1Intersection","c1Result","point","isOutside","c2Intersection","c2Result","distance","shapecast","_triangle","_cachedBox1","_cachedBox2","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","depth","triangle","cachedBox1","cachedBox2","getLeftOffset","getRightEndOffset","left","right","score1","score2","box1","box2","temp","isC1Leaf","c1StopTraversal","end","isC2Leaf","c2StopTraversal","intersectsGeometry","triangle2","cachedMesh","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","computeBoundingBox","set","min","max","update","thisGeometry","thisIndex","index","thisPos","attributes","position","pos","copy","invert","boundsTree","matrix","res","intersectsBounds","box","intersectsBox","intersectsTriangle","tri","a","applyMatrix4","b","c","i","l","i2","l2","leftIntersection","rightIntersection","array","target","intersectBox","bufferStack","_prevBuffer","setBuffer","buffer","push","Float32Array","Uint16Array","Uint32Array","clearBuffer","length","pop"],"mappings":"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","sourcesContent":["/* Generated from \"castFunctions.template.js\". Do not edit. */\r\n\r\n// For speed and readability this script is processed to replace the macro-like calls\r\n// with inline buffer reads. See generate-cast-functions.js.\r\nimport { Box3, Vector3, Mesh, Matrix4 } from 'three';\r\nimport { intersectTris, intersectClosestTri } from './Utils/RayIntersectTriUtlities.js';\r\nimport { arrayToBox } from './Utils/BufferNodeUtils.js';\r\n\r\nimport { OrientedBox } from './Utils/OrientedBox.js';\r\nimport { setTriangle } from './Utils/TriangleUtils.js';\r\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\r\nimport { CONTAINED } from './Constants.js';\r\n\r\nconst boundingBox = new Box3();\r\nconst boxIntersection = new Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nexport function raycast( nodeIndex32, mesh, geometry, raycaster, ray, intersects ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = ( uint16Array[ nodeIndex16 + 15 ] === 0xFFFF );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = uint32Array[ nodeIndex32 + 6 ];\r\n\t\tconst count = uint16Array[ nodeIndex16 + 14 ];\r\n\r\n\t\tintersectTris( mesh, geometry, raycaster, ray, offset, count, intersects );\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = nodeIndex32 + 8;\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( leftIndex, mesh, geometry, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = uint32Array[ nodeIndex32 + 6 ];\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( rightIndex, mesh, geometry, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function raycastFirst( nodeIndex32, mesh, geometry, raycaster, ray ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = ( uint16Array[ nodeIndex16 + 15 ] === 0xFFFF );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = uint32Array[ nodeIndex32 + 6 ];\r\n\t\tconst count = uint16Array[ nodeIndex16 + 14 ];\r\n\t\treturn intersectClosestTri( mesh, geometry, raycaster, ray, offset, count );\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = uint32Array[ nodeIndex32 + 7 ];\r\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = nodeIndex32 + 8;\r\n\t\t\tc2 = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = uint32Array[ nodeIndex32 + 6 ];\r\n\t\t\tc2 = nodeIndex32 + 8;\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\r\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, mesh, geometry, raycaster, ray ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\r\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, mesh, geometry, raycaster, ray ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const shapecast = ( function () {\r\n\r\n\tconst _triangle = new SeparatingAxisTriangle();\r\n\tconst _cachedBox1 = new Box3();\r\n\tconst _cachedBox2 = new Box3();\r\n\r\n\treturn function shapecast(\r\n\t\tnodeIndex32,\r\n\t\tmesh,\r\n\t\tgeometry,\r\n\t\tintersectsBoundsFunc,\r\n\t\tintersectsRangeFunc,\r\n\t\tnodeScoreFunc = null,\r\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\r\n\t\tdepth = 0,\r\n\t\ttriangle = _triangle,\r\n\t\tcachedBox1 = _cachedBox1,\r\n\t\tcachedBox2 = _cachedBox2\r\n\t) {\r\n\r\n\t\t// Define these inside the function so it has access to the local variables needed\r\n\t\t// when converting to the buffer equivalents\r\n\t\tfunction getLeftOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! ( uint16Array[ nodeIndex16 + 15 ] === 0xFFFF ) ) {\r\n\r\n\t\t\t\tnodeIndex32 = nodeIndex32 + 8;\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! ( uint16Array[ nodeIndex16 + 15 ] === 0xFFFF ) ) {\r\n\r\n\t\t\t\t// adjust offset to point to the right node\r\n\t\t\t\tnodeIndex32 = uint32Array[ nodeIndex32 + 6 ];\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return the end offset of the triangle range\r\n\t\t\treturn uint32Array[ nodeIndex32 + 6 ] + uint16Array[ nodeIndex16 + 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tconst isLeaf = ( uint16Array[ nodeIndex16 + 15 ] === 0xFFFF );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = uint32Array[ nodeIndex32 + 6 ];\r\n\t\t\tconst count = uint16Array[ nodeIndex16 + 14 ];\r\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndex32 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = nodeIndex32 + 8;\r\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = cachedBox1;\r\n\t\t\t\tbox2 = cachedBox2;\r\n\r\n\t\t\t\t// bounding data is not offset\r\n\t\t\t\tarrayToBox( c1, float32Array, box1 );\r\n\t\t\t\tarrayToBox( c2, float32Array, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\t// box2 is always set before use below\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check box 1 intersection\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = cachedBox1;\r\n\t\t\t\tarrayToBox( c1, float32Array, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = ( uint16Array[ c1 * 2 + 15 ] === 0xFFFF );\r\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\t\tlet c1StopTraversal;\r\n\t\t\tif ( c1Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c1 );\r\n\t\t\t\tconst end = getRightEndOffset( c1 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1StopTraversal =\r\n\t\t\t\t\tc1Intersection &&\r\n\t\t\t\t\tshapecast(\r\n\t\t\t\t\t\tc1,\r\n\t\t\t\t\t\tmesh,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1,\r\n\t\t\t\t\t\ttriangle,\r\n\t\t\t\t\t\tcachedBox1,\r\n\t\t\t\t\t\tcachedBox2\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c1StopTraversal ) return true;\r\n\r\n\t\t\t// Check box 2 intersection\r\n\t\t\t// cached box2 will have been overwritten by previous traversal\r\n\t\t\tbox2 = cachedBox2;\r\n\t\t\tarrayToBox( c2, float32Array, box2 );\r\n\r\n\t\t\tconst isC2Leaf = ( uint16Array[ c2 * 2 + 15 ] === 0xFFFF );\r\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\t\tlet c2StopTraversal;\r\n\t\t\tif ( c2Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c2 );\r\n\t\t\t\tconst end = getRightEndOffset( c2 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc2StopTraversal =\r\n\t\t\t\t\tc2Intersection &&\r\n\t\t\t\t\tshapecast(\r\n\t\t\t\t\t\tc2,\r\n\t\t\t\t\t\tmesh,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1,\r\n\t\t\t\t\t\ttriangle,\r\n\t\t\t\t\t\tcachedBox1,\r\n\t\t\t\t\t\tcachedBox2\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c2StopTraversal ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new SeparatingAxisTriangle();\r\n\tconst triangle2 = new SeparatingAxisTriangle();\r\n\tconst cachedMesh = new Mesh();\r\n\tconst invertedMat = new Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( nodeIndex32, mesh, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\t\tobb.update();\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tconst isLeaf = ( uint16Array[ nodeIndex16 + 15 ] === 0xFFFF );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst thisGeometry = geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = otherGeometry.index;\r\n\t\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\t\tconst offset = uint32Array[ nodeIndex32 + 6 ];\r\n\t\t\tconst count = uint16Array[ nodeIndex16 + 14 ];\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\tarrayToBox( nodeIndex32, float32Array, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.update();\r\n\r\n\t\t\t\tcachedMesh.geometry = otherGeometry;\r\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( cachedMesh, {\r\n\r\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.update();\r\n\r\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\t\ttriangle2.update();\r\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\t\t\t\tcachedMesh.geometry = null;\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.update();\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.update();\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = nodeIndex32 + 8;\r\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t\tarrayToBox( left, float32Array, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( left, mesh, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\t\t\tarrayToBox( right, float32Array, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( right, mesh, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nfunction intersectRay( nodeIndex32, array, ray, target ) {\r\n\r\n\tarrayToBox( nodeIndex32, array, boundingBox );\r\n\treturn ray.intersectBox( boundingBox, target );\r\n\r\n}\r\n\r\nconst bufferStack = [];\r\nlet _prevBuffer;\r\nlet _float32Array;\r\nlet _uint16Array;\r\nlet _uint32Array;\r\nexport function setBuffer( buffer ) {\r\n\r\n\tif ( _prevBuffer ) {\r\n\r\n\t\tbufferStack.push( _prevBuffer );\r\n\r\n\t}\r\n\r\n\t_prevBuffer = buffer;\r\n\t_float32Array = new Float32Array( buffer );\r\n\t_uint16Array = new Uint16Array( buffer );\r\n\t_uint32Array = new Uint32Array( buffer );\r\n\r\n}\r\n\r\nexport function clearBuffer() {\r\n\r\n\t_prevBuffer = null;\r\n\t_float32Array = null;\r\n\t_uint16Array = null;\r\n\t_uint32Array = null;\r\n\r\n\tif ( bufferStack.length ) {\r\n\r\n\t\tsetBuffer( bufferStack.pop() );\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}