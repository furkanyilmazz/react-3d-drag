'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var _extends = require('@babel/runtime/helpers/extends');
var THREE = require('three');
var React = require('react');
var create = require('zustand');
var shallow = require('zustand/shallow');
var _construct = require('@babel/runtime/helpers/construct');
var Reconciler = require('react-reconciler');
var scheduler = require('scheduler');
var _createForOfIteratorHelperLoose = require('@babel/runtime/helpers/createForOfIteratorHelperLoose');
var useAsset = require('use-asset');
var _inheritsLoose = require('@babel/runtime/helpers/inheritsLoose');
var mergeRefs = require('react-merge-refs');
var useMeasure = require('react-use-measure');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var create__default = /*#__PURE__*/_interopDefault(create);
var shallow__default = /*#__PURE__*/_interopDefault(shallow);
var Reconciler__default = /*#__PURE__*/_interopDefault(Reconciler);
var mergeRefs__default = /*#__PURE__*/_interopDefault(mergeRefs);
var useMeasure__default = /*#__PURE__*/_interopDefault(useMeasure);

var threeTypes = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var is = {
  obj: function obj(a) {
    return a === Object(a) && !is.arr(a) && typeof a !== 'function';
  },
  fun: function fun(a) {
    return typeof a === 'function';
  },
  str: function str(a) {
    return typeof a === 'string';
  },
  num: function num(a) {
    return typeof a === 'number';
  },
  und: function und(a) {
    return a === void 0;
  },
  arr: function arr(a) {
    return Array.isArray(a);
  },
  equ: function equ(a, b) {
    // Wrong type or one of the two undefined, doesn't match
    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b

    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match

    if (is.arr(a) && a == b) return true; // Last resort, go through keys

    var i;

    for (i in a) {
      if (!(i in b)) return false;
    }

    for (i in b) {
      if (a[i] !== b[i]) return false;
    }

    return is.und(i) ? a === b : true;
  }
};

function makeId(event) {
  return (event.eventObject || event.object).uuid + '/' + event.index;
}

function removeInteractivity(store, object) {
  var _store$getState = store.getState(),
      internal = _store$getState.internal; // Removes every trace of an object from the data store


  internal.interaction = internal.interaction.filter(function (o) {
    return o !== object;
  });
  internal.initialHits = internal.initialHits.filter(function (o) {
    return o !== object;
  });
  internal.hovered.forEach(function (value, key) {
    if (value.eventObject === object || value.object === object) {
      internal.hovered.delete(key);
    }
  });
}
function createEvents(store) {
  var temp = new THREE__namespace.Vector3();
  /** Sets up defaultRaycaster */

  function prepareRay(event) {
    var _raycaster$computeOff;

    var state = store.getState();
    var raycaster = state.raycaster,
        mouse = state.mouse,
        camera = state.camera,
        size = state.size; // https://github.com/pmndrs/react-three-fiber/pull/782
    // Events trigger outside of canvas when moved

    var _ref = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event,
        offsetX = _ref.offsetX,
        offsetY = _ref.offsetY;

    var width = size.width,
        height = size.height;
    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);
    raycaster.setFromCamera(mouse, camera);
  }
  /** Calculates delta */


  function calculateDistance(event) {
    var _store$getState2 = store.getState(),
        internal = _store$getState2.internal;

    var dx = event.offsetX - internal.initialClick[0];
    var dy = event.offsetY - internal.initialClick[1];
    return Math.round(Math.sqrt(dx * dx + dy * dy));
  }
  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */


  function filterPointerEvents(objects) {
    return objects.filter(function (obj) {
      return ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(function (name) {
        var _r3f$handlers;

        return (_r3f$handlers = obj.__r3f.handlers) == null ? void 0 : _r3f$handlers['onPointer' + name];
      });
    });
  }

  function intersect(filter) {
    var state = store.getState();
    var raycaster = state.raycaster,
        internal = state.internal; // Skip event handling when noEvents is set

    if (!raycaster.enabled) return [];
    var seen = new Set();
    var intersections = []; // Allow callers to eliminate event objects

    var eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates

    var intersects = raycaster.intersectObjects(eventsObjects, true).filter(function (item) {
      var id = makeId(item);
      if (seen.has(id)) return false;
      seen.add(id);
      return true;
    }); // https://github.com/mrdoob/three.js/issues/16031
    // Allow custom userland intersect sort order

    if (raycaster.filter) intersects = raycaster.filter(intersects, state);

    for (var _iterator = _createForOfIteratorHelperLoose(intersects), _step; !(_step = _iterator()).done;) {
      var _intersect = _step.value;
      var eventObject = _intersect.object; // Bubble event up

      while (eventObject) {
        var _r3f;

        var handlers = (_r3f = eventObject.__r3f) == null ? void 0 : _r3f.handlers;
        if (handlers) intersections.push(_extends({}, _intersect, {
          eventObject: eventObject
        }));
        eventObject = eventObject.parent;
      }
    }

    return intersections;
  }
  /**  Creates filtered intersects and returns an array of positive hits */


  function patchIntersects(intersections, event) {
    var _store$getState3 = store.getState(),
        internal = _store$getState3.internal; // If the interaction is captured, make all capturing targets  part of the
    // intersect.


    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {
      intersections.push.apply(intersections, internal.capturedMap.get(event.pointerId).values());
    }

    return intersections;
  }
  /**  Handles intersections by forwarding them to handlers */


  function handleIntersects(intersections, event, callback) {
    var _store$getState4 = store.getState(),
        raycaster = _store$getState4.raycaster,
        mouse = _store$getState4.mouse,
        camera = _store$getState4.camera,
        internal = _store$getState4.internal; // If anything has been found, forward it to the event listeners


    if (intersections.length) {
      (function () {
        var unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
        var delta = event.type === 'click' ? calculateDistance(event) : 0;

        var releasePointerCapture = function releasePointerCapture(id) {
          return event.target.releasePointerCapture(id);
        };

        var localState = {
          stopped: false
        };

        var _loop = function _loop() {
          var hit = _step2.value;

          var hasPointerCapture = function hasPointerCapture(id) {
            var _internal$capturedMap, _internal$capturedMap2;

            return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;
          };

          var setPointerCapture = function setPointerCapture(id) {
            if (internal.capturedMap.has(id)) {
              // if the pointerId was previously captured, we add the hit to the
              // event capturedMap.
              internal.capturedMap.get(id).set(hit.eventObject, hit);
            } else {
              // if the pointerId was not previously captured, we create a map
              // containing the hitObject, and the hit. hitObject is used for
              // faster access.
              internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));
            } // Call the original event now
            event.target.setPointerCapture(id);
          }; // Add native event props


          var extractEventProps = {};

          for (var prop in Object.getPrototypeOf(event)) {
            var property = event[prop]; // Only copy over atomics, leave functions alone as these should be
            // called as event.nativeEvent.fn()

            if (typeof property !== 'function') extractEventProps[prop] = property;
          }

          var raycastEvent = _extends({}, hit, extractEventProps, {
            spaceX: mouse.x,
            spaceY: mouse.y,
            intersections: intersections,
            stopped: localState.stopped,
            delta: delta,
            unprojectedPoint: unprojectedPoint,
            ray: raycaster.ray,
            camera: camera,
            // Hijack stopPropagation, which just sets a flag
            stopPropagation: function stopPropagation() {
              // https://github.com/pmndrs/react-three-fiber/issues/596
              // Events are not allowed to stop propagation if the pointer has been captured
              var capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...

              if ( // ...if this pointer hasn't been captured
              !capturesForPointer || // ... or if the hit object is capturing the pointer
              capturesForPointer.has(hit.eventObject)) {
                raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records
                // An event handler is only allowed to flush other handlers if it is hovered itself

                if (internal.hovered.size && Array.from(internal.hovered.values()).find(function (i) {
                  return i.eventObject === hit.eventObject;
                })) {
                  // Objects cannot flush out higher up objects that have already caught the event
                  var higher = intersections.slice(0, intersections.indexOf(hit));
                  cancelPointer([].concat(higher, [hit]));
                }
              }
            },
            // there should be a distinction between target and currentTarget
            target: {
              hasPointerCapture: hasPointerCapture,
              setPointerCapture: setPointerCapture,
              releasePointerCapture: releasePointerCapture
            },
            currentTarget: {
              hasPointerCapture: hasPointerCapture,
              setPointerCapture: setPointerCapture,
              releasePointerCapture: releasePointerCapture
            },
            sourceEvent: event,
            // deprecated
            nativeEvent: event
          }); // Call subscribers


          callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation

          if (localState.stopped === true) return "break";
        };

        for (var _iterator2 = _createForOfIteratorHelperLoose(intersections), _step2; !(_step2 = _iterator2()).done;) {
          var _ret = _loop();

          if (_ret === "break") break;
        }
      })();
    }

    return intersections;
  }

  function cancelPointer(hits) {
    var _store$getState5 = store.getState(),
        internal = _store$getState5.internal;

    Array.from(internal.hovered.values()).forEach(function (hoveredObj) {
      // When no objects were hit or the the hovered object wasn't found underneath the cursor
      // we call onPointerOut and delete the object from the hovered-elements map
      if (!hits.length || !hits.find(function (hit) {
        return hit.object === hoveredObj.object && hit.index === hoveredObj.index;
      })) {
        var eventObject = hoveredObj.eventObject;
        var handlers = eventObject.__r3f.handlers;
        internal.hovered.delete(makeId(hoveredObj));

        if (handlers) {
          // Clear out intersects, they are outdated by now
          var data = _extends({}, hoveredObj, {
            intersections: hits || []
          });

          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);
          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);
        }
      }
    });
  }

  var handlePointer = function handlePointer(name) {
    // Deal with cancelation
    switch (name) {
      case 'onPointerLeave':
      case 'onPointerCancel':
        return function () {
          return cancelPointer([]);
        };

      case 'onLostPointerCapture':
        return function (event) {
          if ('pointerId' in event) {
            // this will be a problem if one target releases the pointerId
            // and another one is still keeping it, as the line below
            // indifferently deletes all capturing references.
            store.getState().internal.capturedMap.delete(event.pointerId);
          }

          cancelPointer([]);
        };
    } // Any other pointer goes here ...


    return function (event) {
      var _store$getState6 = store.getState(),
          onPointerMissed = _store$getState6.onPointerMissed,
          internal = _store$getState6.internal;

      prepareRay(event); // Get fresh intersects

      var isPointerMove = name === 'onPointerMove';
      var filter = isPointerMove ? filterPointerEvents : undefined;
      var hits = patchIntersects(intersect(filter), event); // Take care of unhover

      if (isPointerMove) cancelPointer(hits);
      handleIntersects(hits, event, function (data) {
        var eventObject = data.eventObject;
        var handlers = eventObject.__r3f.handlers; // Check presence of handlers

        if (!handlers) return;

        if (isPointerMove) {
          // Move event ...
          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {
            // When enter or out is present take care of hover-state
            var id = makeId(data);
            var hoveredItem = internal.hovered.get(id);

            if (!hoveredItem) {
              // If the object wasn't previously hovered, book it and call its handler
              internal.hovered.set(id, data);
              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);
              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);
            } else if (hoveredItem.stopped) {
              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
              data.stopPropagation();
            }
          } // Call mouse move


          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);
        } else {
          // All other events ...
          var handler = handlers == null ? void 0 : handlers[name];

          if (handler) {
            // Forward all events back to their respective handlers with the exception of click events,
            // which must use the initial target
            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {
              handler(data);
              pointerMissed(event, internal.interaction.filter(function (object) {
                return object !== eventObject;
              }));
            }
          }
        }
      }); // Save initial coordinates on pointer-down

      if (name === 'onPointerDown') {
        internal.initialClick = [event.offsetX, event.offsetY];
        internal.initialHits = hits.map(function (hit) {
          return hit.eventObject;
        });
      } // If a click yields no results, pass it back to the user as a miss


      if ((name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick') && !hits.length) {
        if (calculateDistance(event) <= 2) {
          pointerMissed(event, internal.interaction);
          if (onPointerMissed) onPointerMissed(event);
        }
      }
    };
  };

  function pointerMissed(event, objects) {
    objects.forEach(function (object) {
      var _r3f$handlers2;

      return (_r3f$handlers2 = object.__r3f.handlers) == null ? void 0 : _r3f$handlers2.onPointerMissed == null ? void 0 : _r3f$handlers2.onPointerMissed(event);
    });
  }

  return {
    handlePointer: handlePointer
  };
}

var _excluded$3 = ["args"],
    _excluded2 = ["args"],
    _excluded3 = ["args"];

// Type guard to tell a store from a portal
var isStore = function isStore(def) {
  return def && !!def.getState;
};

var getContainer = function getContainer(container, child) {
  var _container$__r3f$root, _container$__r3f;

  return {
    // If the container is not a root-store then it must be a THREE.Object3D into which part of the
    // scene is portalled into. Now there can be two variants of this, either that object is part of
    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies
    // outside react, in which case we must take the root of the child that is about to be attached to it.
    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,
    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D
    container: isStore(container) ? container.getState().scene : container
  };
};

var DEFAULT = '__default';
var EMPTY = {};
var FILTER = ['children', 'key', 'ref'];
var catalogue = {};

var extend = function extend(objects) {
  return void (catalogue = _extends({}, catalogue, objects));
}; // Each object in the scene carries a small LocalState descriptor


function prepare(object, state) {
  var instance = object;

  if (state != null && state.instance || !instance.__r3f) {
    instance.__r3f = _extends({
      root: null,
      memoizedProps: {},
      objects: []
    }, state);
  }

  return object;
}

function createRenderer(roots) {
  function applyProps(instance, newProps, oldProps, accumulative) {
    var _instance$__r3f, _root$getState, _instance$__r3f2;

    if (oldProps === void 0) {
      oldProps = {};
    }

    if (accumulative === void 0) {
      accumulative = false;
    }

    // Filter equals, events and reserved props
    var localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};
    var root = localState.root;
    var rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};
    var sameProps = [];
    var handlers = [];
    var newMemoizedProps = {};
    var i = 0;
    Object.entries(newProps).forEach(function (_ref) {
      var key = _ref[0],
          entry = _ref[1];

      // we don't want children, ref or key in the memoized props
      if (FILTER.indexOf(key) === -1) {
        newMemoizedProps[key] = entry;
      }
    });

    if (localState.memoizedProps && localState.memoizedProps.args) {
      newMemoizedProps.args = localState.memoizedProps.args;
    }

    if (localState.memoizedProps && localState.memoizedProps.attach) {
      newMemoizedProps.attach = localState.memoizedProps.attach;
    }

    if (instance.__r3f) {
      instance.__r3f.memoizedProps = newMemoizedProps;
    }

    var objectKeys = Object.keys(newProps);

    for (i = 0; i < objectKeys.length; i++) {
      if (is.equ(newProps[objectKeys[i]], oldProps[objectKeys[i]])) {
        sameProps.push(objectKeys[i]);
      } // Event-handlers ...
      //   are functions, that
      //   start with "on", and
      //   contain the name "Pointer", "Click", "DoubleClick", "ContextMenu", or "Wheel"


      if (is.fun(newProps[objectKeys[i]]) && /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(objectKeys[i])) {
        handlers.push(objectKeys[i]);
      }
    } // Catch props that existed, but now exist no more ...


    var leftOvers = [];

    if (accumulative) {
      objectKeys = Object.keys(oldProps);

      for (i = 0; i < objectKeys.length; i++) {
        if (!newProps.hasOwnProperty(objectKeys[i])) {
          leftOvers.push(objectKeys[i]);
        }
      }
    }

    var toFilter = [].concat(sameProps, FILTER); // Instances use "object" as a reserved identifier

    if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.instance) toFilter.push('object');

    var filteredProps = _extends({}, newProps); // Removes sameProps and reserved props from newProps


    objectKeys = Object.keys(filteredProps);

    for (i = 0; i < objectKeys.length; i++) {
      if (toFilter.indexOf(objectKeys[i]) > -1) {
        delete filteredProps[objectKeys[i]];
      }
    } // Collect all new props


    var filteredPropsEntries = Object.entries(filteredProps); // Prepend left-overs so they can be reset or removed
    // Left-overs must come first!

    for (i = 0; i < leftOvers.length; i++) {
      if (leftOvers[i] !== 'children') {
        filteredPropsEntries.unshift([leftOvers[i], DEFAULT + 'remove']);
      }
    }

    if (filteredPropsEntries.length > 0) {
      filteredPropsEntries.forEach(function (_ref2) {
        var key = _ref2[0],
            value = _ref2[1];

        if (!handlers.includes(key)) {
          var currentInstance = instance;
          var targetProp = currentInstance[key];

          if (key.includes('-')) {
            var entries = key.split('-');
            targetProp = entries.reduce(function (acc, key) {
              return acc[key];
            }, instance); // If the target is atomic, it forces us to switch the root

            if (!(targetProp && targetProp.set)) {
              var _entries$reverse = entries.reverse(),
                  _name = _entries$reverse[0],
                  reverseEntries = _entries$reverse.slice(1);

              currentInstance = reverseEntries.reverse().reduce(function (acc, key) {
                return acc[key];
              }, instance);
              key = _name;
            }
          } // https://github.com/mrdoob/three.js/issues/21209
          // HMR/fast-refresh relies on the ability to cancel out props, but threejs
          // has no means to do this. Hence we curate a small collection of value-classes
          // with their respective constructor/set arguments
          // For removed props, try to set default values, if possible


          if (value === DEFAULT + 'remove') {
            if (targetProp && targetProp.constructor) {
              // use the prop constructor to find the default it should be
              value = new targetProp.constructor(newMemoizedProps.args);
            } else if (currentInstance.constructor) {
              // create a blank slate of the instance and copy the particular parameter.
              // @ts-ignore
              var defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);
              value = defaultClassCall[targetProp]; // destory the instance

              if (defaultClassCall.dispose) {
                defaultClassCall.dispose();
              }
            } else {
              // instance does not have constructor, just set it to 0
              value = 0;
            }
          } // Special treatment for objects with support for set/copy, and layers


          if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE__namespace.Layers)) {
            // If value is an array
            if (Array.isArray(value)) {
              if (targetProp.fromArray) {
                targetProp.fromArray(value);
              } else {
                var _targetProp;

                (_targetProp = targetProp).set.apply(_targetProp, value);
              }
            } // Test again target.copy(class) next ...
            else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) {
                targetProp.copy(value);
              } // If nothing else fits, just set the single value, ignore undefined
              // https://github.com/react-spring/react-three-fiber/issues/274
              else if (value !== undefined) {
                  var isColor = targetProp instanceof THREE__namespace.Color; // Allow setting array scalars

                  if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property
                  else if (targetProp instanceof THREE__namespace.Layers && value instanceof THREE__namespace.Layers) targetProp.mask = value.mask; // Otherwise just set ...
                    else targetProp.set(value); // Auto-convert sRGB colors, for now ...
                  // https://github.com/react-spring/react-three-fiber/issues/344

                  if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();
                } // Else, just overwrite the value

          } else {
            currentInstance[key] = value; // Auto-convert sRGB textures, for now ...
            // https://github.com/react-spring/react-three-fiber/issues/344

            if (!rootState.linear && currentInstance[key] instanceof THREE__namespace.Texture) currentInstance[key].encoding = THREE__namespace.sRGBEncoding;
          }

          invalidateInstance(instance);
        }
      }); // Preemptively delete the instance from the containers interaction

      if (accumulative && root && instance.raycast && localState.handlers) {
        localState.handlers = undefined;
        var index = rootState.internal.interaction.indexOf(instance);
        if (index > -1) rootState.internal.interaction.splice(index, 1);
      } // Prep interaction handlers


      if (handlers.length) {
        if (accumulative && root && instance.raycast) {
          rootState.internal.interaction.push(instance);
        } // Add handlers to the instances handler-map


        localState.handlers = handlers.reduce(function (acc, key) {
          var _extends2;

          return _extends({}, acc, (_extends2 = {}, _extends2[key] = newProps[key], _extends2));
        }, {});
      } // Call the update lifecycle when it is being updated, but only when it is part of the scene


      if (instance.parent) updateInstance(instance);
    }
  }

  function invalidateInstance(instance) {
    var _instance$__r3f3, _instance$__r3f3$root;

    var state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();
    if (state && state.internal.frames === 0) state.invalidate();
  }

  function updateInstance(instance) {
    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);
  }

  function createInstance(type, _ref3, root, hostContext, internalInstanceHandle) {
    var _ref3$args = _ref3.args,
        args = _ref3$args === void 0 ? [] : _ref3$args,
        props = _objectWithoutPropertiesLoose(_ref3, _excluded$3);

    var name = "" + type[0].toUpperCase() + type.slice(1);
    var instance; // https://github.com/facebook/react/issues/17147
    // Portals do not give us a root, they are themselves treated as a root by the reconciler
    // In order to figure out the actual root we have to climb through fiber internals :(

    if (!isStore(root) && internalInstanceHandle) {
      var fn = function fn(node) {
        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);
      };

      root = fn(internalInstanceHandle);
    } // Assert that by now we have a valid root


    if (!root || !isStore(root)) throw "No valid root for " + name + "!";

    if (type === 'primitive') {
      if (props.object === undefined) throw "Primitives without 'object' are invalid!";
      var object = props.object;
      instance = prepare(object, {
        root: root,
        instance: true
      });
    } else {
      var target = catalogue[name] || THREE__namespace[name];
      if (!target) throw name + " is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively";
      var isArgsArr = is.arr(args); // Instanciate new object, link it to the root

      instance = prepare(isArgsArr ? _construct(target, args) : new target(args), {
        root: root,
        // append memoized props with args so it's not forgotten
        memoizedProps: {
          args: isArgsArr && args.length === 0 ? null : args
        }
      });
    } // Auto-attach geometries and materials


    if (!('attachFns' in props)) {
      if (name.endsWith('Geometry')) {
        props = _extends({
          attach: 'geometry'
        }, props);
      } else if (name.endsWith('Material')) {
        props = _extends({
          attach: 'material'
        }, props);
      }
    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the
    // view yet. If the callback relies on references for instance, they won't be ready yet, this is
    // why it passes "true" here


    applyProps(instance, props, {});
    return instance;
  }

  function appendChild(parentInstance, child) {
    var addedAsChild = false;

    if (child) {
      // The attach attribute implies that the object attaches itself on the parent
      if (child.attachArray) {
        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];
        parentInstance[child.attachArray].push(child);
      } else if (child.attachObject) {
        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};
        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;
      } else if (child.attach && !is.fun(child.attach)) {
        parentInstance[child.attach] = child;
      } else if (is.arr(child.attachFns)) {
        var _ref4 = child.attachFns,
            attachFn = _ref4[0];

        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {
          parentInstance[attachFn](child);
        } else if (is.fun(attachFn)) {
          attachFn(child, parentInstance);
        }
      } else if (child.isObject3D) {
        // add in the usual parent-child way
        parentInstance.add(child);
        addedAsChild = true;
      }

      if (!addedAsChild) {
        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;
        // that is, anything that's a child in React but not a child in the scenegraph.
        parentInstance.__r3f.objects.push(child);

        child.parent = parentInstance;
      }

      updateInstance(child);
      invalidateInstance(child);
    }
  }

  function insertBefore(parentInstance, child, beforeChild) {
    var added = false;

    if (child) {
      if (child.attachArray) {
        var array = parentInstance[child.attachArray];
        if (!is.arr(array)) parentInstance[child.attachArray] = [];
        array.splice(array.indexOf(beforeChild), 0, child);
      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {
        // attach and attachObject don't have an order anyway, so just append
        return appendChild(parentInstance, child);
      } else if (child.isObject3D) {
        child.parent = parentInstance;
        child.dispatchEvent({
          type: 'added'
        });
        var restSiblings = parentInstance.children.filter(function (sibling) {
          return sibling !== child;
        });
        var index = restSiblings.indexOf(beforeChild);
        parentInstance.children = [].concat(restSiblings.slice(0, index), [child], restSiblings.slice(index));
        added = true;
      }

      if (!added) {
        parentInstance.__r3f.objects.push(child);

        child.parent = parentInstance;
      }

      updateInstance(child);
      invalidateInstance(child);
    }
  }

  function removeRecursive(array, parent, dispose) {
    if (dispose === void 0) {
      dispose = false;
    }

    if (array) [].concat(array).forEach(function (child) {
      return removeChild(parent, child, dispose);
    });
  }

  function removeChild(parentInstance, child, dispose) {
    if (child) {
      var _child$__r3f2;

      if (parentInstance.__r3f.objects) {
        var oldLength = parentInstance.__r3f.objects.length;
        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(function (x) {
          return x !== child;
        });
        var newLength = parentInstance.__r3f.objects.length; // was it in the list?

        if (newLength < oldLength) {
          // we had also set this, so we must clear it now
          child.parent = null;
        }
      } // Remove attachment


      if (child.attachArray) {
        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(function (x) {
          return x !== child;
        });
      } else if (child.attachObject) {
        delete parentInstance[child.attachObject[0]][child.attachObject[1]];
      } else if (child.attach && !is.fun(child.attach)) {
        parentInstance[child.attach] = null;
      } else if (is.arr(child.attachFns)) {
        var _ref5 = child.attachFns,
            detachFn = _ref5[1];

        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {
          parentInstance[detachFn](child);
        } else if (is.fun(detachFn)) {
          detachFn(child, parentInstance);
        }
      } else if (child.isObject3D) {
        var _child$__r3f;

        parentInstance.remove(child); // Remove interactivity

        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {
          removeInteractivity(child.__r3f.root, child);
        }
      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}
      // Never dispose of primitives because their state may be kept outside of React!
      // In order for an object to be able to dispose it has to have
      //   - a dispose method,
      //   - it cannot be an <instance object={...} />
      //   - it cannot be a THREE.Scene, because three has broken it's own api
      //
      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined
      // when the reconciler calls it, but then carry our own check recursively


      var isInstance = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.instance;
      var shouldDispose = dispose === undefined ? child.dispose !== null && !isInstance : dispose; // Remove nested child objects. Primitives should not have objects and children that are
      // attached to them declaratively ...

      if (!isInstance) {
        var _child$__r3f3;

        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);
        removeRecursive(child.children, child, shouldDispose);
      } // Remove references


      if (child.__r3f) {
        delete child.__r3f.root;
        delete child.__r3f.objects;
        delete child.__r3f.handlers;
        delete child.__r3f.memoizedProps;
        if (!isInstance) delete child.__r3f;
      } // Dispose item whenever the reconciler feels like it


      if (shouldDispose && child.dispose && child.type !== 'Scene') {
        scheduler.unstable_runWithPriority(scheduler.unstable_IdlePriority, function () {
          return child.dispose();
        });
      }

      invalidateInstance(parentInstance);
    }
  }

  function switchInstance(instance, type, newProps, fiber) {
    var parent = instance.parent;
    if (!parent) return;
    var newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348
    // When args change the instance has to be re-constructed, which then
    // forces r3f to re-parent the children and non-scene objects

    if (instance.children) {
      instance.children.forEach(function (child) {
        return appendChild(newInstance, child);
      });
      instance.children = [];
    }

    instance.__r3f.objects.forEach(function (child) {
      return appendChild(newInstance, child);
    });

    instance.__r3f.objects = [];
    removeChild(parent, instance);
    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node
    // https://github.com/facebook/react/issues/14983
    // https://github.com/facebook/react/pull/15021
    ;
    [fiber, fiber.alternate].forEach(function (fiber) {
      if (fiber !== null) {
        fiber.stateNode = newInstance;

        if (fiber.ref) {
          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;
        }
      }
    });
  }

  var reconciler = Reconciler__default['default']({
    now: scheduler.unstable_now,
    createInstance: createInstance,
    removeChild: removeChild,
    appendChild: appendChild,
    appendInitialChild: appendChild,
    insertBefore: insertBefore,
    warnsIfNotActing: true,
    supportsMutation: true,
    isPrimaryRenderer: false,
    // @ts-ignore
    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,
    // @ts-ignore
    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,
    // @ts-ignore
    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,
    // @ts-ignore
    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,
    noTimeout: -1,
    appendChildToContainer: function appendChildToContainer(parentInstance, child) {
      var _getContainer = getContainer(parentInstance, child),
          container = _getContainer.container,
          root = _getContainer.root; // Link current root to the default scene


      container.__r3f.root = root;
      appendChild(container, child);
    },
    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
      var _getContainer2 = getContainer(parentInstance, child),
          container = _getContainer2.container;

      removeChild(container, child);
    },
    insertInContainerBefore: function insertInContainerBefore(parentInstance, child, beforeChild) {
      var _getContainer3 = getContainer(parentInstance, child),
          container = _getContainer3.container;

      insertBefore(container, child, beforeChild);
    },
    commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {
      if (instance.__r3f.instance && newProps.object && newProps.object !== instance) {
        // <instance object={...} /> where the object reference has changed
        switchInstance(instance, type, newProps, fiber);
      } else {
        // This is a data object, let's extract critical information about it
        var _newProps$args = newProps.args,
            argsNew = _newProps$args === void 0 ? [] : _newProps$args,
            restNew = _objectWithoutPropertiesLoose(newProps, _excluded2);

        var _oldProps$args = oldProps.args,
            argsOld = _oldProps$args === void 0 ? [] : _oldProps$args,
            restOld = _objectWithoutPropertiesLoose(oldProps, _excluded3); // If it has new props or arguments, then it needs to be re-instanciated


        var hasNewArgs = argsNew.some(function (value, index) {
          return is.obj(value) ? Object.entries(value).some(function (_ref6) {
            var key = _ref6[0],
                val = _ref6[1];
            return val !== argsOld[index][key];
          }) : value !== argsOld[index];
        });

        if (hasNewArgs) {
          // Next we create a new instance and append it again
          switchInstance(instance, type, newProps, fiber);
        } else {
          // Otherwise just overwrite props
          applyProps(instance, restNew, restOld, true);
        }
      }
    },
    hideInstance: function hideInstance(instance) {
      if (instance.isObject3D) {
        instance.visible = false;
        invalidateInstance(instance);
      }
    },
    unhideInstance: function unhideInstance(instance, props) {
      if (instance.isObject3D && props.visible == null || props.visible) {
        instance.visible = true;
        invalidateInstance(instance);
      }
    },
    hideTextInstance: function hideTextInstance() {
      throw new Error('Text is not allowed in the R3F tree.');
    },
    getPublicInstance: function getPublicInstance(instance) {
      // TODO: might fix switchInstance (?)
      return instance;
    },
    getRootHostContext: function getRootHostContext(rootContainer) {
      return EMPTY;
    },
    getChildHostContext: function getChildHostContext(parentHostContext) {
      return EMPTY;
    },
    createTextInstance: function createTextInstance() {},
    finalizeInitialChildren: function finalizeInitialChildren(instance) {
      // https://github.com/facebook/react/issues/20271
      // Returning true will trigger commitMount
      return !!instance.__r3f.handlers;
    },
    commitMount: function commitMount(instance)
    /*, type, props*/
    {
      // https://github.com/facebook/react/issues/20271
      // This will make sure events are only added once to the central container
      if (instance.raycast && instance.__r3f.handlers) instance.__r3f.root.getState().internal.interaction.push(instance);
    },
    prepareUpdate: function prepareUpdate() {
      return EMPTY;
    },
    shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree() {
      return false;
    },
    prepareForCommit: function prepareForCommit() {
      return null;
    },
    preparePortalMount: function preparePortalMount() {// noop
    },
    resetAfterCommit: function resetAfterCommit() {// noop
    },
    shouldSetTextContent: function shouldSetTextContent() {
      return false;
    },
    clearContainer: function clearContainer() {
      return false;
    }
  });
  return {
    reconciler: reconciler,
    applyProps: applyProps
  };
}

var _excluded$2 = ["params"];
var isRenderer = function isRenderer(def) {
  return def && !!def.render;
};
var isOrthographicCamera = function isOrthographicCamera(def) {
  return def && def.isOrthographicCamera;
};
var context = /*#__PURE__*/React__namespace.createContext(null);

var createStore = function createStore(applyProps, _invalidate, _advance, props) {
  var gl = props.gl,
      size = props.size,
      _props$shadows = props.shadows,
      shadows = _props$shadows === void 0 ? false : _props$shadows,
      _props$linear = props.linear,
      linear = _props$linear === void 0 ? false : _props$linear,
      _props$flat = props.flat,
      flat = _props$flat === void 0 ? false : _props$flat,
      _props$vr = props.vr,
      vr = _props$vr === void 0 ? false : _props$vr,
      _props$orthographic = props.orthographic,
      orthographic = _props$orthographic === void 0 ? false : _props$orthographic,
      _props$frameloop = props.frameloop,
      frameloop = _props$frameloop === void 0 ? 'always' : _props$frameloop,
      _props$dpr = props.dpr,
      dpr = _props$dpr === void 0 ? 1 : _props$dpr,
      performance = props.performance,
      _props$clock = props.clock,
      clock = _props$clock === void 0 ? new THREE__namespace.Clock() : _props$clock,
      raycastOptions = props.raycaster,
      cameraOptions = props.camera,
      onPointerMissed = props.onPointerMissed; // Set shadowmap

  if (shadows) {
    gl.shadowMap.enabled = true;
    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE__namespace.PCFSoftShadowMap;
  } // Set color management


  if (!linear) {
    if (!flat) gl.toneMapping = THREE__namespace.ACESFilmicToneMapping;
    gl.outputEncoding = THREE__namespace.sRGBEncoding;
  } // clock.elapsedTime is updated using advance(timestamp)


  if (frameloop === 'never') {
    clock.stop();
    clock.elapsedTime = 0;
  }

  var rootState = create__default['default'](function (set, get) {
    // Create custom raycaster
    var raycaster = new THREE__namespace.Raycaster();

    var _ref = raycastOptions || {},
        params = _ref.params,
        options = _objectWithoutPropertiesLoose(_ref, _excluded$2);

    applyProps(raycaster, _extends({
      enabled: true
    }, options, {
      params: _extends({}, raycaster.params, params)
    }), {}); // Create default camera

    var isCamera = cameraOptions instanceof THREE__namespace.Camera;
    var camera = isCamera ? cameraOptions : orthographic ? new THREE__namespace.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE__namespace.PerspectiveCamera(75, 0, 0.1, 1000);

    if (!isCamera) {
      camera.position.z = 5;
      if (cameraOptions) applyProps(camera, cameraOptions, {}); // Always look at center by default

      camera.lookAt(0, 0, 0);
    }

    function _setDpr(dpr) {
      return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;
    }

    var initialDpr = _setDpr(dpr);

    var position = new THREE__namespace.Vector3();
    var defaultTarget = new THREE__namespace.Vector3();

    function getCurrentViewport(camera, target, size) {
      if (camera === void 0) {
        camera = get().camera;
      }

      if (target === void 0) {
        target = defaultTarget;
      }

      if (size === void 0) {
        size = get().size;
      }

      var _size = size,
          width = _size.width,
          height = _size.height;
      var aspect = width / height;
      var distance = camera.getWorldPosition(position).distanceTo(target);

      if (isOrthographicCamera(camera)) {
        return {
          width: width / camera.zoom,
          height: height / camera.zoom,
          factor: 1,
          distance: distance,
          aspect: aspect
        };
      } else {
        var fov = camera.fov * Math.PI / 180; // convert vertical fov to radians

        var h = 2 * Math.tan(fov / 2) * distance; // visible height

        var w = h * (width / height);
        return {
          width: w,
          height: h,
          factor: width / w,
          distance: distance,
          aspect: aspect
        };
      }
    }

    var performanceTimeout = undefined;

    var setPerformanceCurrent = function setPerformanceCurrent(current) {
      return set(function (state) {
        return {
          performance: _extends({}, state.performance, {
            current: current
          })
        };
      });
    };

    return {
      gl: gl,
      set: set,
      get: get,
      invalidate: function invalidate() {
        return _invalidate(get());
      },
      advance: function advance(timestamp, runGlobalEffects) {
        return _advance(timestamp, runGlobalEffects, get());
      },
      linear: linear,
      flat: flat,
      scene: prepare(new THREE__namespace.Scene()),
      camera: camera,
      controls: null,
      raycaster: raycaster,
      clock: clock,
      mouse: new THREE__namespace.Vector2(),
      vr: vr,
      frameloop: frameloop,
      onPointerMissed: onPointerMissed,
      performance: _extends({
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200
      }, performance, {
        regress: function regress() {
          var state = get(); // Clear timeout

          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance

          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile

          performanceTimeout = setTimeout(function () {
            return setPerformanceCurrent(get().performance.max);
          }, state.performance.debounce);
        }
      }),
      size: {
        width: 0,
        height: 0
      },
      viewport: {
        initialDpr: initialDpr,
        dpr: initialDpr,
        width: 0,
        height: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: getCurrentViewport
      },
      setSize: function setSize(width, height) {
        var size = {
          width: width,
          height: height
        };
        set(function (state) {
          return {
            size: size,
            viewport: _extends({}, state.viewport, getCurrentViewport(camera, defaultTarget, size))
          };
        });
      },
      setDpr: function setDpr(dpr) {
        return set(function (state) {
          return {
            viewport: _extends({}, state.viewport, {
              dpr: _setDpr(dpr)
            })
          };
        });
      },
      events: {
        connected: false
      },
      internal: {
        active: false,
        priority: 0,
        frames: 0,
        lastProps: props,
        interaction: [],
        hovered: new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: new Map(),
        subscribe: function subscribe(ref, priority) {
          if (priority === void 0) {
            priority = 0;
          }

          set(function (_ref2) {
            var internal = _ref2.internal;
            return {
              internal: _extends({}, internal, {
                // If this subscription was given a priority, it takes rendering into its own hands
                // For that reason we switch off automatic rendering and increase the manual flag
                // As long as this flag is positive (there could be multiple render subscription)
                // ..there can be no internal rendering at all
                priority: internal.priority + (priority > 0 ? 1 : 0),
                // Register subscriber and sort layers from lowest to highest, meaning,
                // highest priority renders last (on top of the other frames)
                subscribers: [].concat(internal.subscribers, [{
                  ref: ref,
                  priority: priority
                }]).sort(function (a, b) {
                  return a.priority - b.priority;
                })
              })
            };
          });
          return function () {
            set(function (_ref3) {
              var internal = _ref3.internal;
              return {
                internal: _extends({}, internal, {
                  // Decrease manual flag if this subscription had a priority
                  priority: internal.priority - (priority > 0 ? 1 : 0),
                  // Remove subscriber from list
                  subscribers: internal.subscribers.filter(function (s) {
                    return s.ref !== ref;
                  })
                })
              };
            });
          };
        }
      }
    };
  }); // Resize camera and renderer on changes to size and pixelratio

  rootState.subscribe(function () {
    var _rootState$getState = rootState.getState(),
        camera = _rootState$getState.camera,
        size = _rootState$getState.size,
        viewport = _rootState$getState.viewport,
        internal = _rootState$getState.internal; // https://github.com/pmndrs/react-three-fiber/issues/92
    // Do not mess with the camera if it belongs to the user


    if (!(internal.lastProps.camera instanceof THREE__namespace.Camera)) {
      if (isOrthographicCamera(camera)) {
        camera.left = size.width / -2;
        camera.right = size.width / 2;
        camera.top = size.height / 2;
        camera.bottom = size.height / -2;
      } else {
        camera.aspect = size.width / size.height;
      }

      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178
      // Update matrix world since the renderer is a frame late

      camera.updateMatrixWorld();
    } // Update renderer


    gl.setPixelRatio(viewport.dpr);
    gl.setSize(size.width, size.height);
  }, function (state) {
    return [state.viewport.dpr, state.size];
  }, shallow__default['default']);
  var state = rootState.getState(); // Update size

  if (size) state.setSize(size.width, size.height); // Invalidate on any change

  rootState.subscribe(function (state) {
    return _invalidate(state);
  }); // Return root state

  return rootState;
};

function createSubs(callback, subs) {
  var index = subs.length;
  subs.push(callback);
  return function () {
    return void subs.splice(index, 1);
  };
}

var i;
var globalEffects = [];
var globalAfterEffects = [];
var globalTailEffects = [];
var addEffect = function addEffect(callback) {
  return createSubs(callback, globalEffects);
};
var addAfterEffect = function addAfterEffect(callback) {
  return createSubs(callback, globalAfterEffects);
};
var addTail = function addTail(callback) {
  return createSubs(callback, globalTailEffects);
};

function run(effects, timestamp) {
  for (i = 0; i < effects.length; i++) {
    effects[i](timestamp);
  }
}

function render$1(timestamp, state) {
  // Run local effects
  var delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp

  if (state.frameloop === 'never' && typeof timestamp === 'number') {
    delta = timestamp - state.clock.elapsedTime;
    state.clock.oldTime = state.clock.elapsedTime;
    state.clock.elapsedTime = timestamp;
  } // Call subscribers (useFrame)


  for (i = 0; i < state.internal.subscribers.length; i++) {
    state.internal.subscribers[i].ref.current(state, delta);
  } // Render content


  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count

  state.internal.frames = Math.max(0, state.internal.frames - 1);
  return state.frameloop === 'always' ? 1 : state.internal.frames;
}

function createLoop(roots) {
  var running = false;
  var repeat;

  function loop(timestamp) {
    running = true;
    repeat = 0; // Run effects

    run(globalEffects, timestamp); // Render all roots

    roots.forEach(function (root) {
      var state = root.store.getState(); // If the frameloop is invalidated, do not run another frame

      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);
    }); // Run after-effects

    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop

    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops
    else run(globalTailEffects, timestamp); // Flag end of operation

    running = false;
  }

  function invalidate(state) {
    if (!state) return roots.forEach(function (root) {
      return invalidate(root.store.getState());
    });
    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60

    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it

    if (!running) {
      running = true;
      requestAnimationFrame(loop);
    }
  }

  function advance(timestamp, runGlobalEffects, state) {
    if (runGlobalEffects === void 0) {
      runGlobalEffects = true;
    }

    if (runGlobalEffects) run(globalEffects, timestamp);
    if (!state) roots.forEach(function (root) {
      return render$1(timestamp, root.store.getState());
    });else render$1(timestamp, state);
    if (runGlobalEffects) run(globalAfterEffects, timestamp);
  }

  return {
    loop: loop,
    invalidate: invalidate,
    advance: advance
  };
}

function createPointerEvents(store) {
  var _createEvents = createEvents(store),
      handlePointer = _createEvents.handlePointer;

  var names = {
    onClick: ['click', false],
    onContextMenu: ['contextmenu', false],
    onDoubleClick: ['dblclick', false],
    onWheel: ['wheel', true],
    onPointerDown: ['pointerdown', true],
    onPointerUp: ['pointerup', true],
    onPointerLeave: ['pointerleave', true],
    onPointerMove: ['pointermove', true],
    onPointerCancel: ['pointercancel', true],
    onLostPointerCapture: ['lostpointercapture', true]
  };
  return {
    connected: false,
    handlers: Object.keys(names).reduce(function (acc, key) {
      var _extends2;

      return _extends({}, acc, (_extends2 = {}, _extends2[key] = handlePointer(key), _extends2));
    }, {}),
    connect: function connect(target) {
      var _events$handlers;

      var _store$getState = store.getState(),
          set = _store$getState.set,
          events = _store$getState.events;

      events.disconnect == null ? void 0 : events.disconnect();
      set(function (state) {
        return {
          events: _extends({}, state.events, {
            connected: target
          })
        };
      });
      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(function (_ref) {
        var name = _ref[0],
            event = _ref[1];
        var _names = names[name],
            eventName = _names[0],
            passive = _names[1];
        target.addEventListener(eventName, event, {
          passive: passive
        });
      });
    },
    disconnect: function disconnect() {
      var _store$getState2 = store.getState(),
          set = _store$getState2.set,
          events = _store$getState2.events;

      if (events.connected) {
        var _events$handlers2;

        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(function (_ref2) {
          var name = _ref2[0],
              event = _ref2[1];

          if (events && events.connected instanceof HTMLElement) {
            var _names2 = names[name],
                eventName = _names2[0];
            events.connected.removeEventListener(eventName, event);
          }
        });
        set(function (state) {
          return {
            events: _extends({}, state.events, {
              connected: false
            })
          };
        });
      }
    }
  };
}

var _excluded$1 = ["children", "fallback", "tabIndex", "resize", "id", "style", "className", "events"];
// React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser.
var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;

function Block(_ref) {
  var set = _ref.set;
  useIsomorphicLayoutEffect(function () {
    set(new Promise(function () {
      return null;
    }));
    return function () {
      return set(false);
    };
  }, []);
  return null;
}

var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      error: false
    };
    return _this;
  }

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error) {
    this.props.set(error);
  };

  _proto.render = function render() {
    return this.state.error ? null : this.props.children;
  };

  return ErrorBoundary;
}(React__namespace.Component);

ErrorBoundary.getDerivedStateFromError = function () {
  return {
    error: true
  };
};

var Canvas = /*#__PURE__*/React__namespace.forwardRef(function Canvas(_ref2, forwardedRef) {
  var children = _ref2.children,
      fallback = _ref2.fallback,
      tabIndex = _ref2.tabIndex,
      resize = _ref2.resize,
      id = _ref2.id,
      style = _ref2.style,
      className = _ref2.className,
      events = _ref2.events,
      props = _objectWithoutPropertiesLoose(_ref2, _excluded$1);

  var _useMeasure = useMeasure__default['default'](_extends({
    scroll: true,
    debounce: {
      scroll: 50,
      resize: 0
    }
  }, resize)),
      containerRef = _useMeasure[0],
      size = _useMeasure[1];

  var canvasRef = React__namespace.useRef(null);

  var _React$useState = React__namespace.useState(false),
      block = _React$useState[0],
      setBlock = _React$useState[1];

  var _React$useState2 = React__namespace.useState(false),
      error = _React$useState2[0],
      setError = _React$useState2[1]; // Suspend this component if block is a promise (2nd run)


  if (block) throw block; // Throw exception outwards if anything within canvas throws

  if (error) throw error; // Execute JSX in the reconciler as a layout-effect

  useIsomorphicLayoutEffect(function () {
    if (size.width > 0 && size.height > 0) {
      render( /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
        set: setError
      }, /*#__PURE__*/React__namespace.createElement(React__namespace.Suspense, {
        fallback: /*#__PURE__*/React__namespace.createElement(Block, {
          set: setBlock
        })
      }, children)), canvasRef.current, _extends({}, props, {
        size: size,
        events: events || createPointerEvents
      }));
    }
  }, [size, children]);
  useIsomorphicLayoutEffect(function () {
    var container = canvasRef.current;
    return function () {
      return unmountComponentAtNode(container);
    };
  }, []);
  return /*#__PURE__*/React__namespace.createElement("div", {
    ref: containerRef,
    id: id,
    className: className,
    tabIndex: tabIndex,
    style: _extends({
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden'
    }, style)
  }, /*#__PURE__*/React__namespace.createElement("canvas", {
    ref: mergeRefs__default['default']([canvasRef, forwardedRef]),
    style: {
      display: 'block'
    }
  }, fallback));
});

function useThree(selector, equalityFn) {
  if (selector === void 0) {
    selector = function selector(state) {
      return state;
    };
  }

  var useStore = React__namespace.useContext(context);
  if (!useStore) throw "R3F hooks can only be used within the Canvas component!";
  return useStore(selector, equalityFn);
}
function useFrame(callback, renderPriority) {
  if (renderPriority === void 0) {
    renderPriority = 0;
  }

  var subscribe = React__namespace.useContext(context).getState().internal.subscribe; // Update ref

  var ref = React__namespace.useRef(callback);
  React__namespace.useLayoutEffect(function () {
    return void (ref.current = callback);
  }, [callback]); // Subscribe/unsub

  React__namespace.useLayoutEffect(function () {
    var unsubscribe = subscribe(ref, renderPriority);
    return function () {
      return unsubscribe();
    };
  }, [renderPriority, subscribe]);
  return null;
}

function buildGraph(object) {
  var data = {
    nodes: {},
    materials: {}
  };

  if (object) {
    object.traverse(function (obj) {
      if (obj.name) {
        data.nodes[obj.name] = obj;
      }

      if (obj.material && !data.materials[obj.material.name]) {
        data.materials[obj.material.name] = obj.material;
      }
    });
  }

  return data;
}

function useGraph(object) {
  return React__namespace.useMemo(function () {
    return buildGraph(object);
  }, [object]);
}

function loadingFn(extensions, onProgress) {
  return function (Proto) {
    // Construct new loader and run extensions
    var loader = new Proto();
    if (extensions) extensions(loader); // Go through the urls and load them

    for (var _len = arguments.length, input = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      input[_key - 1] = arguments[_key];
    }

    return Promise.all(input.map(function (input) {
      return new Promise(function (res, reject) {
        return loader.load(input, function (data) {
          if (data.scene) Object.assign(data, buildGraph(data.scene));
          res(data);
        }, onProgress, function (error) {
          return reject("Could not load " + input + ": " + error.message);
        });
      });
    }));
  };
}

function useLoader(Proto, input, extensions, onProgress) {
  // Use suspense to load async assets
  var keys = Array.isArray(input) ? input : [input];
  var results = useAsset.useAsset.apply(void 0, [loadingFn(extensions, onProgress), Proto].concat(keys)); // Return the object/s

  return Array.isArray(input) ? results : results[0];
}

useLoader.preload = function (Proto, input, extensions) {
  var keys = Array.isArray(input) ? input : [input];
  return useAsset.useAsset.preload.apply(useAsset.useAsset, [loadingFn(extensions), Proto].concat(keys));
};

var _excluded = ["gl", "size", "mode", "events", "onCreated"];
var roots = new Map();
var modes = ['legacy', 'blocking', 'concurrent'];

var _createLoop = createLoop(roots),
    invalidate = _createLoop.invalidate,
    advance = _createLoop.advance;

var _createRenderer = createRenderer(),
    reconciler = _createRenderer.reconciler,
    applyProps = _createRenderer.applyProps;

var createRendererInstance = function createRendererInstance(gl, canvas) {
  return isRenderer(gl) ? gl : new THREE__namespace.WebGLRenderer(_extends({
    powerPreference: 'high-performance',
    canvas: canvas,
    antialias: true,
    alpha: true
  }, gl));
};

function render(element, canvas, _temp) {
  var _store;

  var _ref = _temp === void 0 ? {} : _temp,
      gl = _ref.gl,
      size = _ref.size,
      _ref$mode = _ref.mode,
      mode = _ref$mode === void 0 ? modes[1] : _ref$mode,
      events = _ref.events,
      onCreated = _ref.onCreated,
      props = _objectWithoutPropertiesLoose(_ref, _excluded);

  // Allow size to take on container bounds initially
  if (!size) {
    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;

    size = {
      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,
      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0
    };
  }

  var root = roots.get(canvas);
  var fiber = root == null ? void 0 : root.fiber;
  var store = root == null ? void 0 : root.store;
  var state = (_store = store) == null ? void 0 : _store.getState();

  if (fiber && state) {
    var lastProps = state.internal.lastProps; // When a root was found, see if any fundamental props must be changed or exchanged
    // Check pixelratio

    if (props.dpr !== undefined && !is.equ(lastProps.dpr, props.dpr)) state.setDpr(props.dpr); // Check size

    if (!is.equ(lastProps.size, size)) state.setSize(size.width, size.height); // For some props we want to reset the entire root
    // Changes to the color-space

    var linearChanged = props.linear !== lastProps.linear;

    if (linearChanged) {
      unmountComponentAtNode(canvas);
      fiber = undefined;
    }
  }

  if (!fiber) {
    // If no root has been found, make one
    // Create gl
    var glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested

    if (props.vr) {
      glRenderer.xr.enabled = true;
      glRenderer.setAnimationLoop(function (timestamp) {
        return advance(timestamp, true);
      });
    } // Create store


    store = createStore(applyProps, invalidate, advance, _extends({
      gl: glRenderer,
      size: size
    }, props));

    var _state = store.getState(); // Create renderer


    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it

    roots.set(canvas, {
      fiber: fiber,
      store: store
    }); // Store events internally

    if (events) _state.set({
      events: events(store)
    });
  }

  if (store && fiber) {
    reconciler.updateContainer( /*#__PURE__*/React__namespace.createElement(Provider, {
      store: store,
      element: element,
      onCreated: onCreated,
      target: canvas
    }), fiber, null, function () {
      return undefined;
    });
    return store;
  } else {
    throw 'Error creating root!';
  }
}

function Provider(_ref2) {
  var store = _ref2.store,
      element = _ref2.element,
      onCreated = _ref2.onCreated,
      target = _ref2.target;
  React__namespace.useEffect(function () {
    var state = store.getState(); // Flag the canvas active, rendering will now begin

    state.set(function (state) {
      return {
        internal: _extends({}, state.internal, {
          active: true
        })
      };
    }); // Connect events

    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered

    if (onCreated) onCreated(state);
  }, []);
  return /*#__PURE__*/React__namespace.createElement(context.Provider, {
    value: store
  }, element);
}

function unmountComponentAtNode(canvas, callback) {
  var root = roots.get(canvas);
  var fiber = root == null ? void 0 : root.fiber;

  if (fiber) {
    var _state2 = root == null ? void 0 : root.store.getState();

    if (_state2) _state2.internal.active = false;
    reconciler.updateContainer(null, fiber, null, function () {
      if (_state2) {
        setTimeout(function () {
          var _state2$gl, _state2$gl$renderList, _state2$gl2;

          _state2.events.disconnect == null ? void 0 : _state2.events.disconnect();
          (_state2$gl = _state2.gl) == null ? void 0 : (_state2$gl$renderList = _state2$gl.renderLists) == null ? void 0 : _state2$gl$renderList.dispose == null ? void 0 : _state2$gl$renderList.dispose();
          (_state2$gl2 = _state2.gl) == null ? void 0 : _state2$gl2.forceContextLoss == null ? void 0 : _state2$gl2.forceContextLoss();
          dispose(_state2);
          roots.delete(canvas);
          if (callback) callback(canvas);
        }, 500);
      }
    });
  }
}

function dispose(obj) {
  if (obj.dispose && obj.type !== 'Scene') obj.dispose();

  for (var p in obj) {
    var _dispose, _ref3;
    (_dispose = (_ref3 = p).dispose) == null ? void 0 : _dispose.call(_ref3);
    delete obj[p];
  }
}

var act = reconciler.act;
var hasSymbol = is.fun(Symbol) && Symbol.for;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;

function createPortal(children, container, implementation, key) {
  if (key === void 0) {
    key = null;
  }

  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: prepare(container),
    implementation: implementation
  };
}

reconciler.injectIntoDevTools({
  bundleType: 0 ,
  rendererPackageName: '@react-three/fiber',
  version: '17.0.2'
});

exports.Canvas = Canvas;
exports.ReactThreeFiber = threeTypes;
exports._roots = roots;
exports.act = act;
exports.addAfterEffect = addAfterEffect;
exports.addEffect = addEffect;
exports.addTail = addTail;
exports.advance = advance;
exports.applyProps = applyProps;
exports.context = context;
exports.createPortal = createPortal;
exports.dispose = dispose;
exports.events = createPointerEvents;
exports.extend = extend;
exports.invalidate = invalidate;
exports.reconciler = reconciler;
exports.render = render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.useFrame = useFrame;
exports.useGraph = useGraph;
exports.useLoader = useLoader;
exports.useThree = useThree;
