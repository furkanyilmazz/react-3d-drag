{"ast":null,"code":"import { Box3, Vector3 } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nconst box1 = new Box3();\nconst box2 = new Box3();\nconst vec = new Vector3();\nexport class MeshBVHDebug {\n  constructor(bvh, geometry) {\n    this.bvh = bvh;\n    this.geometry = geometry;\n  } // Returns a simple, human readable object that represents the BVH.\n\n\n  getJSONStructure() {\n    const {\n      bvh\n    } = this;\n    const depthStack = [];\n    bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n      const info = {\n        bounds: arrayToBox(boundingData, new Box3())\n      };\n\n      if (isLeaf) {\n        info.count = count;\n        info.offset = offset;\n      } else {\n        info.left = null;\n        info.right = null;\n      }\n\n      depthStack[depth] = info; // traversal hits the left then right node\n\n      const parent = depthStack[depth - 1];\n\n      if (parent) {\n        if (parent.left === null) {\n          parent.left = info;\n        } else {\n          parent.right = info;\n        }\n      }\n    });\n    return depthStack[0];\n  }\n\n  validateBounds() {\n    const {\n      bvh,\n      geometry\n    } = this;\n    const depthStack = [];\n    const index = geometry.index;\n    const position = geometry.getAttribute('position');\n    let passes = true;\n    bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n      const info = {\n        depth,\n        isLeaf,\n        boundingData,\n        offset,\n        count\n      };\n      depthStack[depth] = info;\n      arrayToBox(boundingData, box1);\n      const parent = depthStack[depth - 1];\n\n      if (isLeaf) {\n        // check triangles\n        for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n          const i0 = index.getX(i);\n          const i1 = index.getX(i + 1);\n          const i2 = index.getX(i + 2);\n          let isContained;\n          vec.fromBufferAttribute(position, i0);\n          isContained = box1.containsPoint(vec);\n          vec.fromBufferAttribute(position, i1);\n          isContained = isContained && box1.containsPoint(vec);\n          vec.fromBufferAttribute(position, i2);\n          isContained = isContained && box1.containsPoint(vec);\n          console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n          passes = passes && isContained;\n        }\n      }\n\n      if (parent) {\n        // check if my bounds fit in my parents\n        arrayToBox(boundingData, box2);\n        const isContained = box2.containsBox(box1);\n        console.assert(isContained, 'Parent bounds does not fully contain child.');\n        passes = passes && isContained;\n      }\n    });\n    return passes;\n  }\n\n}","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/MeshBVHDebug.js"],"names":["Box3","Vector3","arrayToBox","box1","box2","vec","MeshBVHDebug","constructor","bvh","geometry","getJSONStructure","depthStack","traverse","depth","isLeaf","boundingData","offset","count","info","bounds","left","right","parent","validateBounds","index","position","getAttribute","passes","i","l","i0","getX","i1","i2","isContained","fromBufferAttribute","containsPoint","console","assert","containsBox"],"mappings":"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","sourcesContent":["import { Box3, Vector3 } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nconst box1 = new Box3();\r\nconst box2 = new Box3();\r\nconst vec = new Vector3();\r\n\r\nexport class MeshBVHDebug {\r\n\r\n\tconstructor( bvh, geometry ) {\r\n\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\t// Returns a simple, human readable object that represents the BVH.\r\n\tgetJSONStructure() {\r\n\r\n\t\tconst { bvh } = this;\r\n\t\tconst depthStack = [];\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tbounds: arrayToBox( boundingData, new Box3() ),\r\n\t\t\t};\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tinfo.count = count;\r\n\t\t\t\tinfo.offset = offset;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinfo.left = null;\r\n\t\t\t\tinfo.right = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\t// traversal hits the left then right node\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\t\tparent.left = info;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tparent.right = info;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn depthStack[ 0 ];\r\n\r\n\t}\r\n\r\n\tvalidateBounds() {\r\n\r\n\t\tconst { bvh, geometry } = this;\r\n\t\tconst depthStack = [];\r\n\t\tconst index = geometry.index;\r\n\t\tconst position = geometry.getAttribute( 'position' );\r\n\t\tlet passes = true;\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tdepth,\r\n\t\t\t\tisLeaf,\r\n\t\t\t\tboundingData,\r\n\t\t\t\toffset,\r\n\t\t\t\tcount,\r\n\t\t\t};\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\tarrayToBox( boundingData, box1 );\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t// check triangles\r\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i0 );\r\n\t\t\t\t\tisContained = box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i1 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i2 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t// check if my bounds fit in my parents\r\n\t\t\t\tarrayToBox( boundingData, box2 );\r\n\r\n\t\t\t\tconst isContained = box2.containsBox( box1 );\r\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn passes;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}