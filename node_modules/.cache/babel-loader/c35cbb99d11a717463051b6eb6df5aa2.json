{"ast":null,"code":"import { Box3, BufferAttribute } from 'three';\nimport MeshBVHNode from './MeshBVHNode.js';\nimport { arrayToBox, boxToArray, getLongestEdgeIndex } from './Utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH } from './Constants.js'; // https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\n\nconst FLOAT32_EPSILON = Math.pow(2, -24);\nconst xyzFields = ['x', 'y', 'z'];\nconst boxTemp = new Box3();\n\nfunction ensureIndex(geo) {\n  if (!geo.index) {\n    const vertexCount = geo.attributes.position.count;\n    const index = new (vertexCount > 65535 ? Uint32Array : Uint16Array)(vertexCount);\n    geo.setIndex(new BufferAttribute(index, 1));\n\n    for (let i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n} // Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\n\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{\n      offset: 0,\n      count: geo.index.count / 3\n    }];\n  }\n\n  const ranges = [];\n  const rangeBoundaries = new Set();\n\n  for (const group of geo.groups) {\n    rangeBoundaries.add(group.start);\n    rangeBoundaries.add(group.start + group.count);\n  } // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\n\n  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);\n\n  for (let i = 0; i < sortedBoundaries.length - 1; i++) {\n    const start = sortedBoundaries[i],\n          end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: start / 3,\n      count: (end - start) / 3\n    });\n  }\n\n  return ranges;\n} // computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\n\n\nfunction getBounds(triangleBounds, offset, count, target, centroidTarget = null) {\n  let minx = Infinity;\n  let miny = Infinity;\n  let minz = Infinity;\n  let maxx = -Infinity;\n  let maxy = -Infinity;\n  let maxz = -Infinity;\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  const includeCentroid = centroidTarget !== null;\n\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    const hx = triangleBounds[i + 1];\n    const lx = cx - hx;\n    const rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    const hy = triangleBounds[i + 3];\n    const ly = cy - hy;\n    const ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    const hz = triangleBounds[i + 5];\n    const lz = cz - hz;\n    const rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n} // A stand alone function for retrieving the centroid bounds.\n\n\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n} // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\n\n\nfunction partition(index, triangleBounds, sahPlanes, offset, count, split) {\n  let left = offset;\n  let right = offset + count - 1;\n  const pos = split.pos;\n  const axisOffset = split.axis * 2; // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    }\n\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n      for (let i = 0; i < 3; i++) {\n        let t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        let t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        let t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n\n      if (sahPlanes) {\n        for (let i = 0; i < 3; i++) {\n          let t = sahPlanes[i][left];\n          sahPlanes[i][left] = sahPlanes[i][right];\n          sahPlanes[i][right] = t;\n        }\n      }\n\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\n\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, sahPlanes, offset, count, strategy) {\n  let axis = -1;\n  let pos = 0; // Center\n\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    // Surface Area Heuristic\n    // In order to make this code more terse, the x, y, and z\n    // variables of various structures have been stuffed into\n    // 0, 1, and 2 array indices so they can be easily computed\n    // and accessed within array iteration\n    // Cost values defineed for operations. We're using bounds for traversal, so\n    // the cost of traversing one more layer is more than intersecting a triangle.\n    const TRAVERSAL_COST = 3;\n    const INTERSECTION_COST = 1;\n    const bb = arrayToBox(nodeBoundingData, boxTemp); // Define the width, height, and depth of the bounds as a box\n\n    const dim = [bb.max.x - bb.min.x, bb.max.y - bb.min.y, bb.max.z - bb.min.z];\n    const sa = 2 * (dim[0] * dim[1] + dim[0] * dim[2] + dim[1] * dim[2]); // Get the precalculated planes based for the triangles we're\n    // testing here\n\n    const filteredLists = [[], [], []];\n\n    for (let i = offset, end = offset + count; i < end; i++) {\n      for (let v = 0; v < 3; v++) {\n        filteredLists[v].push(sahPlanes[v][i]);\n      }\n    }\n\n    filteredLists.forEach(planes => planes.sort((a, b) => a.p - b.p)); // this bounds surface area, left bound SA, left triangles, right bound SA, right triangles\n\n    const getCost = (sa, sal, nl, sar, nr) => TRAVERSAL_COST + INTERSECTION_COST * (sal / sa * nl + sar / sa * nr); // the cost of _not_ splitting into smaller bounds\n\n\n    const noSplitCost = INTERSECTION_COST * count;\n    axis = -1;\n    let bestCost = noSplitCost;\n\n    for (let i = 0; i < 3; i++) {\n      // o1 and o2 represent the _other_ two axes in the\n      // the space. So if we're checking the x (0) dimension,\n      // then o1 and o2 would be y and z (1 and 2)\n      const o1 = (i + 1) % 3;\n      const o2 = (i + 2) % 3;\n      const bmin = bb.min[xyzFields[i]];\n      const bmax = bb.max[xyzFields[i]];\n      const planes = filteredLists[i]; // The number of left and right triangles on either side\n      // given the current split\n\n      let nl = 0;\n      let nr = count;\n\n      for (let p = 0; p < planes.length; p++) {\n        const pinfo = planes[p]; // As the plane moves, we have to increment or decrement the\n        // number of triangles on either side of the plane\n\n        nl++;\n        nr--; // the distance from the plane to the edge of the broader bounds\n\n        const ldim = pinfo.p - bmin;\n        const rdim = bmax - pinfo.p; // same for the other two dimensions\n\n        let ldimo1 = dim[o1],\n            rdimo1 = dim[o1];\n        let ldimo2 = dim[o2],\n            rdimo2 = dim[o2];\n        /*\r\n        // compute the other bounding planes for the box\r\n        // if only the current triangles are considered to\r\n        // be in the box\r\n        // This is really slow and probably not really worth it\r\n        const o1planes = sahPlanes[o1];\r\n        const o2planes = sahPlanes[o2];\r\n        let lmin = Infinity, lmax = -Infinity;\r\n        let rmin = Infinity, rmax = -Infinity;\r\n        planes.forEach((p, i) => {\r\n        const tri2 = p.tri * 2;\r\n        const inf1 = o1planes[tri2 + 0];\r\n        const inf2 = o1planes[tri2 + 1];\r\n        if (i <= nl) {\r\n        lmin = Math.min(inf1.p, inf2.p, lmin);\r\n        lmax = Math.max(inf1.p, inf2.p, lmax);\r\n        }\r\n        if (i >= nr) {\r\n        rmin = Math.min(inf1.p, inf2.p, rmin);\r\n        rmax = Math.max(inf1.p, inf2.p, rmax);\r\n        }\r\n        })\r\n        ldimo1 = Math.min(lmax - lmin, ldimo1);\r\n        rdimo1 = Math.min(rmax - rmin, rdimo1);\r\n        \t\tplanes.forEach((p, i) => {\r\n        const tri2 = p.tri * 2;\r\n        const inf1 = o2planes[tri2 + 0];\r\n        const inf2 = o2planes[tri2 + 1];\r\n        if (i <= nl) {\r\n        lmin = Math.min(inf1.p, inf2.p, lmin);\r\n        lmax = Math.max(inf1.p, inf2.p, lmax);\r\n        }\r\n        if (i >= nr) {\r\n        rmin = Math.min(inf1.p, inf2.p, rmin);\r\n        rmax = Math.max(inf1.p, inf2.p, rmax);\r\n        }\r\n        })\r\n        ldimo2 = Math.min(lmax - lmin, ldimo2);\r\n        rdimo2 = Math.min(rmax - rmin, rdimo2);\r\n        */\n        // surface areas and cost\n\n        const sal = 2 * (ldimo1 * ldimo2 + ldimo1 * ldim + ldimo2 * ldim);\n        const sar = 2 * (rdimo1 * rdimo2 + rdimo1 * rdim + rdimo2 * rdim);\n        const cost = getCost(sa, sal, nl, sar, nr);\n\n        if (cost < bestCost) {\n          axis = i;\n          pos = pinfo.p;\n          bestCost = cost;\n        }\n      }\n    }\n  }\n\n  return {\n    axis,\n    pos\n  };\n} // returns the average coordinate on the specified axis of the all the provided triangles\n\n\nfunction getAverage(triangleBounds, offset, count, axis) {\n  let avg = 0;\n\n  for (let i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n\n  return avg / count;\n}\n\nfunction computeSAHPlanes(triangleBounds) {\n  const triCount = triangleBounds.length / 6;\n  const sahPlanes = [new Array(triCount), new Array(triCount), new Array(triCount)];\n\n  for (let tri = 0; tri < triCount; tri++) {\n    for (let el = 0; el < 3; el++) {\n      sahPlanes[el][tri] = {\n        p: triangleBounds[tri * 6 + el * 2],\n        tri\n      };\n    }\n  }\n\n  return sahPlanes;\n} // precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\n\n\nfunction computeTriangleBounds(geo) {\n  const verts = geo.attributes.position.array;\n  const index = geo.index.array;\n  const triCount = index.length / 3;\n  const triangleBounds = new Float32Array(triCount * 6);\n\n  for (let tri = 0; tri < triCount; tri++) {\n    const tri3 = tri * 3;\n    const tri6 = tri * 6;\n    const ai = index[tri3 + 0] * 3;\n    const bi = index[tri3 + 1] * 3;\n    const ci = index[tri3 + 2] * 3;\n\n    for (let el = 0; el < 3; el++) {\n      const a = verts[ai + el];\n      const b = verts[bi + el];\n      const c = verts[ci + el];\n      let min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      let max = a;\n      if (b > max) max = b;\n      if (c > max) max = c; // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n\n      const halfExtents = (max - min) / 2;\n      const el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n    }\n  }\n\n  return triangleBounds;\n}\n\nexport function buildTree(geo, options) {\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n\n      if (verbose) {\n        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n        console.warn(this, geo);\n      }\n    } // early out if we've met our capacity\n\n\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      node.offset = offset;\n      node.count = count;\n      return node;\n    } // Find where to split the volume\n\n\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, sahPlanes, offset, count, strategy);\n\n    if (split.axis === -1) {\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    const splitOffset = partition(indexArray, triangleBounds, sahPlanes, offset, count, split); // create the two new child nodes\n\n    if (splitOffset === offset || splitOffset === offset + count) {\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis; // create the left child and compute its bounding box\n\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1); // repeat for right\n\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n\n    return node;\n  }\n\n  ensureIndex(geo);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  const triangleBounds = computeTriangleBounds(geo);\n  const sahPlanes = options.strategy === SAH ? computeSAHPlanes(triangleBounds) : null;\n  const indexArray = geo.index.array;\n  const maxDepth = options.maxDepth;\n  const verbose = options.verbose;\n  const maxLeafTris = options.maxLeafTris;\n  const strategy = options.strategy;\n  let reachedMaxDepth = false;\n  const roots = [];\n  const ranges = getRootIndexRanges(geo);\n\n  if (ranges.length === 1) {\n    const root = new MeshBVHNode();\n    const range = ranges[0];\n\n    if (geo.boundingBox != null) {\n      root.boundingData = boxToArray(geo.boundingBox);\n      getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    } else {\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n    }\n\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    for (let range of ranges) {\n      const root = new MeshBVHNode();\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n      roots.push(root);\n    }\n  }\n\n  return roots;\n}\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\nexport function buildPackedTree(geo, options) {\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  const roots = buildTree(geo, options);\n  let float32Array;\n  let uint32Array;\n  let uint16Array;\n  const packedRoots = [];\n\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i];\n    let nodeCount = countNodes(root);\n    const buffer = new ArrayBuffer(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n\n  return packedRoots;\n\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n\n  function populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = !!node.count;\n    const boundingData = node.boundingData;\n\n    for (let i = 0; i < 6; i++) {\n      float32Array[stride4Offset + i] = boundingData[i];\n    }\n\n    if (isLeaf) {\n      const offset = node.offset;\n      const count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      const left = node.left;\n      const right = node.right;\n      const splitAxis = node.splitAxis;\n      let nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/buildFunctions.js"],"names":["Box3","BufferAttribute","MeshBVHNode","arrayToBox","boxToArray","getLongestEdgeIndex","CENTER","AVERAGE","SAH","FLOAT32_EPSILON","Math","pow","xyzFields","boxTemp","ensureIndex","geo","index","vertexCount","attributes","position","count","Uint32Array","Uint16Array","setIndex","i","getRootIndexRanges","groups","length","offset","ranges","rangeBoundaries","Set","group","add","start","sortedBoundaries","Array","from","values","sort","a","b","end","push","getBounds","triangleBounds","target","centroidTarget","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","partition","sahPlanes","split","left","right","pos","axisOffset","axis","t0","t1","t2","t","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","getAverage","TRAVERSAL_COST","INTERSECTION_COST","bb","dim","max","x","min","y","z","sa","filteredLists","v","forEach","planes","p","getCost","sal","nl","sar","nr","noSplitCost","bestCost","o1","o2","bmin","bmax","pinfo","ldim","rdim","ldimo1","rdimo1","ldimo2","rdimo2","cost","avg","computeSAHPlanes","triCount","tri","el","computeTriangleBounds","verts","array","Float32Array","tri3","tri6","ai","bi","ci","c","halfExtents","el2","abs","buildTree","options","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","console","warn","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","roots","root","range","boundingBox","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","ArrayBuffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error"],"mappings":"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","sourcesContent":["import { Box3, BufferAttribute } from 'three';\r\nimport MeshBVHNode from './MeshBVHNode.js';\r\nimport { arrayToBox, boxToArray, getLongestEdgeIndex } from './Utils/ArrayBoxUtilities.js';\r\nimport { CENTER, AVERAGE, SAH } from './Constants.js';\r\n\r\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\r\nconst FLOAT32_EPSILON = Math.pow( 2, - 24 );\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\nconst boxTemp = new Box3();\r\n\r\nfunction ensureIndex( geo ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst index = new ( vertexCount > 65535 ? Uint32Array : Uint16Array )( vertexCount );\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nfunction getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\trangeBoundaries.add( group.start );\r\n\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t}\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\r\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\r\n// These are computed together to avoid redundant accesses to bounds array.\r\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\r\n\r\n\tlet minx = Infinity;\r\n\tlet miny = Infinity;\r\n\tlet minz = Infinity;\r\n\tlet maxx = - Infinity;\r\n\tlet maxy = - Infinity;\r\n\tlet maxz = - Infinity;\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tconst includeCentroid = centroidTarget !== null;\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tconst hx = triangleBounds[ i + 1 ];\r\n\t\tconst lx = cx - hx;\r\n\t\tconst rx = cx + hx;\r\n\t\tif ( lx < minx ) minx = lx;\r\n\t\tif ( rx > maxx ) maxx = rx;\r\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\r\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tconst hy = triangleBounds[ i + 3 ];\r\n\t\tconst ly = cy - hy;\r\n\t\tconst ry = cy + hy;\r\n\t\tif ( ly < miny ) miny = ly;\r\n\t\tif ( ry > maxy ) maxy = ry;\r\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\r\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tconst hz = triangleBounds[ i + 5 ];\r\n\t\tconst lz = cz - hz;\r\n\t\tconst rz = cz + hz;\r\n\t\tif ( lz < minz ) minz = lz;\r\n\t\tif ( rz > maxz ) maxz = rz;\r\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\r\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\ttarget[ 0 ] = minx;\r\n\ttarget[ 1 ] = miny;\r\n\ttarget[ 2 ] = minz;\r\n\r\n\ttarget[ 3 ] = maxx;\r\n\ttarget[ 4 ] = maxy;\r\n\ttarget[ 5 ] = maxz;\r\n\r\n\tif ( includeCentroid ) {\r\n\r\n\t\tcentroidTarget[ 0 ] = cminx;\r\n\t\tcentroidTarget[ 1 ] = cminy;\r\n\t\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\t\tcentroidTarget[ 3 ] = cmaxx;\r\n\t\tcentroidTarget[ 4 ] = cmaxy;\r\n\t\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A stand alone function for retrieving the centroid bounds.\r\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tif ( cx < cminx ) cminx = cx;\r\n\t\tif ( cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tif ( cy < cminy ) cminy = cy;\r\n\t\tif ( cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tif ( cz < cminz ) cminz = cz;\r\n\t\tif ( cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\tcentroidTarget[ 0 ] = cminx;\r\n\tcentroidTarget[ 1 ] = cminy;\r\n\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\tcentroidTarget[ 3 ] = cmaxx;\r\n\tcentroidTarget[ 4 ] = cmaxy;\r\n\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n}\r\n\r\n\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition( index, triangleBounds, sahPlanes, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\r\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\r\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sahPlanes ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tlet t = sahPlanes[ i ][ left ];\r\n\t\t\t\t\tsahPlanes[ i ][ left ] = sahPlanes[ i ][ right ];\r\n\t\t\t\t\tsahPlanes[ i ][ right ] = t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, sahPlanes, offset, count, strategy ) {\r\n\r\n\tlet axis = - 1;\r\n\tlet pos = 0;\r\n\r\n\t// Center\r\n\tif ( strategy === CENTER ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === SAH ) {\r\n\r\n\t\t// Surface Area Heuristic\r\n\t\t// In order to make this code more terse, the x, y, and z\r\n\t\t// variables of various structures have been stuffed into\r\n\t\t// 0, 1, and 2 array indices so they can be easily computed\r\n\t\t// and accessed within array iteration\r\n\r\n\t\t// Cost values defineed for operations. We're using bounds for traversal, so\r\n\t\t// the cost of traversing one more layer is more than intersecting a triangle.\r\n\t\tconst TRAVERSAL_COST = 3;\r\n\t\tconst INTERSECTION_COST = 1;\r\n\t\tconst bb = arrayToBox( nodeBoundingData, boxTemp );\r\n\r\n\t\t// Define the width, height, and depth of the bounds as a box\r\n\t\tconst dim = [\r\n\t\t\tbb.max.x - bb.min.x,\r\n\t\t\tbb.max.y - bb.min.y,\r\n\t\t\tbb.max.z - bb.min.z\r\n\t\t];\r\n\t\tconst sa = 2 * ( dim[ 0 ] * dim[ 1 ] + dim[ 0 ] * dim[ 2 ] + dim[ 1 ] * dim[ 2 ] );\r\n\r\n\t\t// Get the precalculated planes based for the triangles we're\r\n\t\t// testing here\r\n\t\tconst filteredLists = [[], [], []];\r\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\tfor ( let v = 0; v < 3; v ++ ) {\r\n\r\n\t\t\t\tfilteredLists[ v ].push( sahPlanes[ v ][ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfilteredLists.forEach( planes => planes.sort( ( a, b ) => a.p - b.p ) );\r\n\r\n\t\t// this bounds surface area, left bound SA, left triangles, right bound SA, right triangles\r\n\t\tconst getCost = ( sa, sal, nl, sar, nr ) =>\r\n\t\t\t  TRAVERSAL_COST + INTERSECTION_COST * ( ( sal / sa ) * nl + ( sar / sa ) * nr );\r\n\r\n\t\t// the cost of _not_ splitting into smaller bounds\r\n\t\tconst noSplitCost = INTERSECTION_COST * count;\r\n\r\n\t\taxis = - 1;\r\n\t\tlet bestCost = noSplitCost;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t// o1 and o2 represent the _other_ two axes in the\r\n\t\t\t// the space. So if we're checking the x (0) dimension,\r\n\t\t\t// then o1 and o2 would be y and z (1 and 2)\r\n\t\t\tconst o1 = ( i + 1 ) % 3;\r\n\t\t\tconst o2 = ( i + 2 ) % 3;\r\n\r\n\t\t\tconst bmin = bb.min[ xyzFields[ i ] ];\r\n\t\t\tconst bmax = bb.max[ xyzFields[ i ] ];\r\n\t\t\tconst planes = filteredLists[ i ];\r\n\r\n\t\t\t// The number of left and right triangles on either side\r\n\t\t\t// given the current split\r\n\t\t\tlet nl = 0;\r\n\t\t\tlet nr = count;\r\n\t\t\tfor ( let p = 0; p < planes.length; p ++ ) {\r\n\r\n\t\t\t\tconst pinfo = planes[ p ];\r\n\r\n\t\t\t\t// As the plane moves, we have to increment or decrement the\r\n\t\t\t\t// number of triangles on either side of the plane\r\n\t\t\t\tnl ++;\r\n\t\t\t\tnr --;\r\n\r\n\t\t\t\t// the distance from the plane to the edge of the broader bounds\r\n\t\t\t\tconst ldim = pinfo.p - bmin;\r\n\t\t\t\tconst rdim = bmax - pinfo.p;\r\n\r\n\t\t\t\t// same for the other two dimensions\r\n\t\t\t\tlet ldimo1 = dim[ o1 ], rdimo1 = dim[ o1 ];\r\n\t\t\t\tlet ldimo2 = dim[ o2 ], rdimo2 = dim[ o2 ];\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t// compute the other bounding planes for the box\r\n\t\t\t\t// if only the current triangles are considered to\r\n\t\t\t\t// be in the box\r\n\t\t\t\t// This is really slow and probably not really worth it\r\n\t\t\t\tconst o1planes = sahPlanes[o1];\r\n\t\t\t\tconst o2planes = sahPlanes[o2];\r\n\t\t\t\tlet lmin = Infinity, lmax = -Infinity;\r\n\t\t\t\tlet rmin = Infinity, rmax = -Infinity;\r\n\t\t\t\tplanes.forEach((p, i) => {\r\n\t\t\t\tconst tri2 = p.tri * 2;\r\n\t\t\t\tconst inf1 = o1planes[tri2 + 0];\r\n\t\t\t\tconst inf2 = o1planes[tri2 + 1];\r\n\t\t\t\tif (i <= nl) {\r\n\t\t\t\tlmin = Math.min(inf1.p, inf2.p, lmin);\r\n\t\t\t\tlmax = Math.max(inf1.p, inf2.p, lmax);\r\n\t\t\t\t}\r\n\t\t\t\tif (i >= nr) {\r\n\t\t\t\trmin = Math.min(inf1.p, inf2.p, rmin);\r\n\t\t\t\trmax = Math.max(inf1.p, inf2.p, rmax);\r\n\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tldimo1 = Math.min(lmax - lmin, ldimo1);\r\n\t\t\t\trdimo1 = Math.min(rmax - rmin, rdimo1);\r\n\r\n\t\t\t\tplanes.forEach((p, i) => {\r\n\t\t\t\tconst tri2 = p.tri * 2;\r\n\t\t\t\tconst inf1 = o2planes[tri2 + 0];\r\n\t\t\t\tconst inf2 = o2planes[tri2 + 1];\r\n\t\t\t\tif (i <= nl) {\r\n\t\t\t\tlmin = Math.min(inf1.p, inf2.p, lmin);\r\n\t\t\t\tlmax = Math.max(inf1.p, inf2.p, lmax);\r\n\t\t\t\t}\r\n\t\t\t\tif (i >= nr) {\r\n\t\t\t\trmin = Math.min(inf1.p, inf2.p, rmin);\r\n\t\t\t\trmax = Math.max(inf1.p, inf2.p, rmax);\r\n\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tldimo2 = Math.min(lmax - lmin, ldimo2);\r\n\t\t\t\trdimo2 = Math.min(rmax - rmin, rdimo2);\r\n\t\t\t\t*/\r\n\r\n\t\t\t\t// surface areas and cost\r\n\t\t\t\tconst sal = 2 * ( ldimo1 * ldimo2 + ldimo1 * ldim + ldimo2 * ldim );\r\n\t\t\t\tconst sar = 2 * ( rdimo1 * rdimo2 + rdimo1 * rdim + rdimo2 * rdim );\r\n\t\t\t\tconst cost = getCost( sa, sal, nl, sar, nr );\r\n\r\n\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\taxis = i;\r\n\t\t\t\t\tpos = pinfo.p;\r\n\t\t\t\t\tbestCost = cost;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn { axis, pos };\r\n\r\n}\r\n\r\n// returns the average coordinate on the specified axis of the all the provided triangles\r\nfunction getAverage( triangleBounds, offset, count, axis ) {\r\n\r\n\tlet avg = 0;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\r\n\r\n\t}\r\n\r\n\treturn avg / count;\r\n\r\n}\r\n\r\nfunction computeSAHPlanes( triangleBounds ) {\r\n\r\n\tconst triCount = triangleBounds.length / 6;\r\n\tconst sahPlanes = [ new Array( triCount ), new Array( triCount ), new Array( triCount ) ];\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tsahPlanes[ el ][ tri ] = { p: triangleBounds[ tri * 6 + el * 2 ], tri };\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn sahPlanes;\r\n\r\n}\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeTriangleBounds( geo ) {\r\n\r\n\tconst verts = geo.attributes.position.array;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst triangleBounds = new Float32Array( triCount * 6 );\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst tri3 = tri * 3;\r\n\t\tconst tri6 = tri * 6;\r\n\t\tconst ai = index[ tri3 + 0 ] * 3;\r\n\t\tconst bi = index[ tri3 + 1 ] * 3;\r\n\t\tconst ci = index[ tri3 + 2 ] * 3;\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tconst a = verts[ ai + el ];\r\n\t\t\tconst b = verts[ bi + el ];\r\n\t\t\tconst c = verts[ ci + el ];\r\n\r\n\t\t\tlet min = a;\r\n\t\t\tif ( b < min ) min = b;\r\n\t\t\tif ( c < min ) min = c;\r\n\r\n\t\t\tlet max = a;\r\n\t\t\tif ( b > max ) max = b;\r\n\t\t\tif ( c > max ) max = c;\r\n\r\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\r\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\r\n\t\t\t// worked with.\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tconst el2 = el * 2;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn triangleBounds;\r\n\r\n}\r\n\r\nexport function buildTree( geo, options ) {\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( this, geo );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, sahPlanes, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partition( indexArray, triangleBounds, sahPlanes, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\t\t\tleft.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\t\t\tright.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n\tensureIndex( geo );\r\n\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tconst triangleBounds = computeTriangleBounds( geo );\r\n\tconst sahPlanes = options.strategy === SAH ? computeSAHPlanes( triangleBounds ) : null;\r\n\tconst indexArray = geo.index.array;\r\n\tconst maxDepth = options.maxDepth;\r\n\tconst verbose = options.verbose;\r\n\tconst maxLeafTris = options.maxLeafTris;\r\n\tconst strategy = options.strategy;\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst roots = [];\r\n\tconst ranges = getRootIndexRanges( geo );\r\n\r\n\tif ( ranges.length === 1 ) {\r\n\r\n\t\tconst root = new MeshBVHNode();\r\n\t\tconst range = ranges[ 0 ];\r\n\r\n\t\tif ( geo.boundingBox != null ) {\r\n\r\n\t\t\troot.boundingData = boxToArray( geo.boundingBox );\r\n\t\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\r\n\r\n\t\t} else {\r\n\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t}\r\n\r\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\troots.push( root );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\t\troots.push( root );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn roots;\r\n\r\n}\r\n\r\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\r\n\r\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\r\n\r\nexport function buildPackedTree( geo, options ) {\r\n\r\n\t// boundingData  \t\t\t\t: 6 float32\r\n\t// right / offset \t\t\t\t: 1 uint32\r\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\n\tconst roots = buildTree( geo, options );\r\n\r\n\tlet float32Array;\r\n\tlet uint32Array;\r\n\tlet uint16Array;\r\n\tconst packedRoots = [];\r\n\tfor ( let i = 0; i < roots.length; i ++ ) {\r\n\r\n\t\tconst root = roots[ i ];\r\n\t\tlet nodeCount = countNodes( root );\r\n\r\n\t\tconst buffer = new ArrayBuffer( BYTES_PER_NODE * nodeCount );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tpopulateBuffer( 0, root );\r\n\t\tpackedRoots.push( buffer );\r\n\r\n\t}\r\n\r\n\treturn packedRoots;\r\n\r\n\tfunction countNodes( node ) {\r\n\r\n\t\tif ( node.count ) {\r\n\r\n\t\t\treturn 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction populateBuffer( byteOffset, node ) {\r\n\r\n\t\tconst stride4Offset = byteOffset / 4;\r\n\t\tconst stride2Offset = byteOffset / 2;\r\n\t\tconst isLeaf = ! ! node.count;\r\n\t\tconst boundingData = node.boundingData;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node.left;\r\n\t\t\tconst right = node.right;\r\n\t\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\t\tlet nextUnusedPointer;\r\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\t\treturn nextUnusedPointer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}