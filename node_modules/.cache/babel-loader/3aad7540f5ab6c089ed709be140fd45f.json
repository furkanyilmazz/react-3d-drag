{"ast":null,"code":"import { LineBasicMaterial, Box3Helper, Box3, Group, LineSegments } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nconst wiremat = new LineBasicMaterial({\n  color: 0x00FF88,\n  transparent: true,\n  opacity: 0.3\n});\nconst boxGeom = new Box3Helper().geometry;\nlet boundingBox = new Box3();\n\nclass MeshBVHRootVisualizer extends Group {\n  constructor(mesh, depth = 10, group = 0) {\n    super('MeshBVHRootVisualizer');\n    this.depth = depth;\n    this.mesh = mesh;\n    this._group = group;\n    this.update();\n  }\n\n  update() {\n    const boundsTree = this.mesh.geometry.boundsTree;\n    let requiredChildren = 0;\n\n    if (boundsTree) {\n      boundsTree.traverse((depth, isLeaf, boundingData, offsetOrSplit, countOrIsUnfinished) => {\n        let isTerminal = isLeaf || countOrIsUnfinished; // Stop traversal\n\n        if (depth >= this.depth) {\n          return true;\n        }\n\n        if (depth === this.depth - 1 || isTerminal) {\n          let m = requiredChildren < this.children.length ? this.children[requiredChildren] : null;\n\n          if (!m) {\n            m = new LineSegments(boxGeom, wiremat);\n\n            m.raycast = () => [];\n\n            this.add(m);\n          }\n\n          requiredChildren++;\n          arrayToBox(boundingData, boundingBox);\n          boundingBox.getCenter(m.position);\n          m.scale.subVectors(boundingBox.max, boundingBox.min).multiplyScalar(0.5);\n          if (m.scale.x === 0) m.scale.x = Number.EPSILON;\n          if (m.scale.y === 0) m.scale.y = Number.EPSILON;\n          if (m.scale.z === 0) m.scale.z = Number.EPSILON;\n        }\n      });\n    }\n\n    while (this.children.length > requiredChildren) this.remove(this.children.pop());\n  }\n\n}\n\nclass MeshBVHVisualizer extends Group {\n  constructor(mesh, depth = 10) {\n    super('MeshBVHVisualizer');\n    this.depth = depth;\n    this.mesh = mesh;\n    this._roots = [];\n    this.update();\n  }\n\n  update() {\n    const bvh = this.mesh.geometry.boundsTree;\n    const totalRoots = bvh ? bvh._roots.length : 0;\n\n    while (this._roots.length > totalRoots) {\n      this._roots.pop();\n    }\n\n    for (let i = 0; i < totalRoots; i++) {\n      if (i >= this._roots.length) {\n        const root = new MeshBVHRootVisualizer(this.mesh, this.depth, i);\n        this.add(root);\n\n        this._roots.push(root);\n      } else {\n        let root = this._roots[i];\n        root.depth = this.depth;\n        root.mesh = this.mesh;\n        root.update();\n      }\n    }\n  }\n\n  updateMatrixWorld(...args) {\n    this.position.copy(this.mesh.position);\n    this.rotation.copy(this.mesh.rotation);\n    this.scale.copy(this.mesh.scale);\n    super.updateMatrixWorld(...args);\n  }\n\n  copy(source) {\n    this.depth = source.depth;\n    this.mesh = source.mesh;\n  }\n\n  clone() {\n    return new MeshBVHVisualizer(this.mesh, this.depth);\n  }\n\n}\n\nexport default MeshBVHVisualizer;","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/MeshBVHVisualizer.js"],"names":["LineBasicMaterial","Box3Helper","Box3","Group","LineSegments","arrayToBox","wiremat","color","transparent","opacity","boxGeom","geometry","boundingBox","MeshBVHRootVisualizer","constructor","mesh","depth","group","_group","update","boundsTree","requiredChildren","traverse","isLeaf","boundingData","offsetOrSplit","countOrIsUnfinished","isTerminal","m","children","length","raycast","add","getCenter","position","scale","subVectors","max","min","multiplyScalar","x","Number","EPSILON","y","z","remove","pop","MeshBVHVisualizer","_roots","bvh","totalRoots","i","root","push","updateMatrixWorld","args","copy","rotation","source","clone"],"mappings":"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","sourcesContent":["import { LineBasicMaterial, Box3Helper, Box3, Group, LineSegments } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\n\r\nconst wiremat = new LineBasicMaterial( { color: 0x00FF88, transparent: true, opacity: 0.3 } );\r\nconst boxGeom = new Box3Helper().geometry;\r\nlet boundingBox = new Box3();\r\n\r\nclass MeshBVHRootVisualizer extends Group {\r\n\r\n\tconstructor( mesh, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper( 'MeshBVHRootVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis._group = group;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tlet requiredChildren = 0;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, countOrIsUnfinished ) => {\r\n\r\n\t\t\t\tlet isTerminal = isLeaf || countOrIsUnfinished;\r\n\r\n\t\t\t\t// Stop traversal\r\n\t\t\t\tif ( depth >= this.depth ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( depth === this.depth - 1 || isTerminal ) {\r\n\r\n\t\t\t\t\tlet m = requiredChildren < this.children.length ? this.children[ requiredChildren ] : null;\r\n\t\t\t\t\tif ( ! m ) {\r\n\r\n\t\t\t\t\t\tm = new LineSegments( boxGeom, wiremat );\r\n\t\t\t\t\t\tm.raycast = () => [];\r\n\t\t\t\t\t\tthis.add( m );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trequiredChildren ++;\r\n\t\t\t\t\tarrayToBox( boundingData, boundingBox );\r\n\t\t\t\t\tboundingBox.getCenter( m.position );\r\n\t\t\t\t\tm.scale.subVectors( boundingBox.max, boundingBox.min ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\tif ( m.scale.x === 0 ) m.scale.x = Number.EPSILON;\r\n\t\t\t\t\tif ( m.scale.y === 0 ) m.scale.y = Number.EPSILON;\r\n\t\t\t\t\tif ( m.scale.z === 0 ) m.scale.z = Number.EPSILON;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( this.children.length > requiredChildren ) this.remove( this.children.pop() );\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper( 'MeshBVHVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis._roots = [];\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet root = this._roots[ i ];\r\n\t\t\t\troot.depth = this.depth;\r\n\t\t\t\troot.mesh = this.mesh;\r\n\t\t\t\troot.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport default MeshBVHVisualizer;\r\n"]},"metadata":{},"sourceType":"module"}