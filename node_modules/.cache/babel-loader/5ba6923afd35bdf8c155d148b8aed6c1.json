{"ast":null,"code":"import _classCallCheck from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Box3, Vector3, Matrix4, Sphere, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { SeparatingAxisTriangle } from './SeparatingAxisTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\nexport var OrientedBox = /*#__PURE__*/function (_Box) {\n  _inherits(OrientedBox, _Box);\n\n  var _super = _createSuper(OrientedBox);\n\n  function OrientedBox() {\n    var _this;\n\n    _classCallCheck(this, OrientedBox);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.isOrientedBox = true;\n    _this.matrix = new Matrix4();\n    _this.invMatrix = new Matrix4();\n    _this.points = new Array(8).fill().map(function () {\n      return new Vector3();\n    });\n    _this.satAxes = new Array(3).fill().map(function () {\n      return new Vector3();\n    });\n    _this.satBounds = new Array(3).fill().map(function () {\n      return new SeparatingAxisBounds();\n    });\n    _this.alignedSatBounds = new Array(3).fill().map(function () {\n      return new SeparatingAxisBounds();\n    });\n    _this.sphere = new Sphere();\n    return _this;\n  }\n\n  _createClass(OrientedBox, [{\n    key: \"set\",\n    value: function set(min, max, matrix) {\n      _get(_getPrototypeOf(OrientedBox.prototype), \"set\", this).call(this, min, max);\n\n      this.matrix = matrix;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      _get(_getPrototypeOf(OrientedBox.prototype), \"copy\", this).call(this, other);\n\n      this.matrix.copy(other.matrix);\n    }\n  }]);\n\n  return OrientedBox;\n}(Box3);\n\nOrientedBox.prototype.update = function () {\n  return function update() {\n    var matrix = this.matrix;\n    var min = this.min;\n    var max = this.max;\n    var points = this.points;\n\n    for (var x = 0; x <= 1; x++) {\n      for (var y = 0; y <= 1; y++) {\n        for (var z = 0; z <= 1; z++) {\n          var i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;\n          var v = points[i];\n          v.x = x ? max.x : min.x;\n          v.y = y ? max.y : min.y;\n          v.z = z ? max.z : min.z;\n          v.applyMatrix4(matrix);\n        }\n      }\n    }\n\n    this.sphere.setFromPoints(this.points);\n    var satBounds = this.satBounds;\n    var satAxes = this.satAxes;\n    var minVec = points[0];\n\n    for (var _i = 0; _i < 3; _i++) {\n      var axis = satAxes[_i];\n      var sb = satBounds[_i];\n      var index = 1 << _i;\n      var pi = points[index];\n      axis.subVectors(minVec, pi);\n      sb.setFromPoints(axis, points);\n    }\n\n    var alignedSatBounds = this.alignedSatBounds;\n    alignedSatBounds[0].setFromPointsField(points, 'x');\n    alignedSatBounds[1].setFromPointsField(points, 'y');\n    alignedSatBounds[2].setFromPointsField(points, 'z');\n    this.invMatrix.copy(this.matrix).invert();\n  };\n}();\n\nOrientedBox.prototype.intersectsBox = function () {\n  var aabbBounds = new SeparatingAxisBounds();\n  return function intersectsBox(box) {\n    if (!box.intersectsSphere(this.sphere)) return false;\n    var min = box.min;\n    var max = box.max;\n    var satBounds = this.satBounds;\n    var satAxes = this.satAxes;\n    var alignedSatBounds = this.alignedSatBounds;\n    aabbBounds.min = min.x;\n    aabbBounds.max = max.x;\n    if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n    aabbBounds.min = min.y;\n    aabbBounds.max = max.y;\n    if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n    aabbBounds.min = min.z;\n    aabbBounds.max = max.z;\n    if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n\n    for (var i = 0; i < 3; i++) {\n      var axis = satAxes[i];\n      var sb = satBounds[i];\n      aabbBounds.setFromBox(axis, box);\n      if (sb.isSeparated(aabbBounds)) return false;\n    }\n\n    return true;\n  };\n}();\n\nOrientedBox.prototype.intersectsTriangle = function () {\n  var saTri = new SeparatingAxisTriangle();\n  var pointsArr = new Array(3);\n  var cachedSatBounds = new SeparatingAxisBounds();\n  var cachedSatBounds2 = new SeparatingAxisBounds();\n  var cachedAxis = new Vector3();\n  return function intersectsTriangle(triangle) {\n    if (!triangle.isSeparatingAxisTriangle) {\n      saTri.copy(triangle);\n      saTri.update();\n      triangle = saTri;\n    } else if (triangle.needsUpdate) {\n      triangle.update();\n    }\n\n    var satBounds = this.satBounds;\n    var satAxes = this.satAxes;\n    pointsArr[0] = triangle.a;\n    pointsArr[1] = triangle.b;\n    pointsArr[2] = triangle.c;\n\n    for (var i = 0; i < 3; i++) {\n      var sb = satBounds[i];\n      var sa = satAxes[i];\n      cachedSatBounds.setFromPoints(sa, pointsArr);\n      if (sb.isSeparated(cachedSatBounds)) return false;\n    }\n\n    var triSatBounds = triangle.satBounds;\n    var triSatAxes = triangle.satAxes;\n    var points = this.points;\n\n    for (var _i2 = 0; _i2 < 3; _i2++) {\n      var _sb = triSatBounds[_i2];\n      var _sa = triSatAxes[_i2];\n      cachedSatBounds.setFromPoints(_sa, points);\n      if (_sb.isSeparated(cachedSatBounds)) return false;\n    } // check crossed axes\n\n\n    for (var _i3 = 0; _i3 < 3; _i3++) {\n      var sa1 = satAxes[_i3];\n\n      for (var i2 = 0; i2 < 4; i2++) {\n        var sa2 = triSatAxes[i2];\n        cachedAxis.crossVectors(sa1, sa2);\n        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n        cachedSatBounds2.setFromPoints(cachedAxis, points);\n        if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n      }\n    }\n\n    return true;\n  };\n}();\n\nOrientedBox.prototype.closestPointToPoint = function () {\n  return function closestPointToPoint(point, target1) {\n    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n    return target1;\n  };\n}();\n\nOrientedBox.prototype.distanceToPoint = function () {\n  var target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\n\nOrientedBox.prototype.distanceToBox = function () {\n  var xyzFields = ['x', 'y', 'z'];\n  var segments1 = new Array(12).fill().map(function () {\n    return new Line3();\n  });\n  var segments2 = new Array(12).fill().map(function () {\n    return new Line3();\n  });\n  var point1 = new Vector3();\n  var point2 = new Vector3();\n  return function distanceToBox(box) {\n    var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    if (this.intersectsBox(box)) {\n      if (target1 || target2) {\n        box.getCenter(point2);\n        this.closestPointToPoint(point2, point1);\n        box.closestPointToPoint(point1, point2);\n        if (target1) target1.copy(point1);\n        if (target2) target2.copy(point2);\n      }\n\n      return 0;\n    }\n\n    var threshold2 = threshold * threshold;\n    var min = box.min;\n    var max = box.max;\n    var points = this.points; // iterate over every edge and compare distances\n\n    var closestDistanceSq = Infinity; // check over all these points\n\n    for (var i = 0; i < 8; i++) {\n      var p = points[i];\n      point2.copy(p).clamp(min, max);\n      var dist = p.distanceToSquared(point2);\n\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(p);\n        if (target2) target2.copy(point2);\n        if (dist < threshold2) return Math.sqrt(dist);\n      }\n    } // generate and check all line segment distances\n\n\n    var count = 0;\n\n    for (var _i4 = 0; _i4 < 3; _i4++) {\n      for (var i1 = 0; i1 <= 1; i1++) {\n        for (var i2 = 0; i2 <= 1; i2++) {\n          var nextIndex = (_i4 + 1) % 3;\n          var nextIndex2 = (_i4 + 2) % 3; // get obb line segments\n\n          var index = i1 << nextIndex | i2 << nextIndex2;\n          var index2 = 1 << _i4 | i1 << nextIndex | i2 << nextIndex2;\n          var p1 = points[index];\n          var p2 = points[index2];\n          var line1 = segments1[count];\n          line1.set(p1, p2); // get aabb line segments\n\n          var f1 = xyzFields[_i4];\n          var f2 = xyzFields[nextIndex];\n          var f3 = xyzFields[nextIndex2];\n          var line2 = segments2[count];\n          var start = line2.start;\n          var end = line2.end;\n          start[f1] = min[f1];\n          start[f2] = i1 ? min[f2] : max[f2];\n          start[f3] = i2 ? min[f3] : max[f2];\n          end[f1] = max[f1];\n          end[f2] = i1 ? min[f2] : max[f2];\n          end[f3] = i2 ? min[f3] : max[f2];\n          count++;\n        }\n      }\n    } // check all the other boxes point\n\n\n    for (var x = 0; x <= 1; x++) {\n      for (var y = 0; y <= 1; y++) {\n        for (var z = 0; z <= 1; z++) {\n          point2.x = x ? max.x : min.x;\n          point2.y = y ? max.y : min.y;\n          point2.z = z ? max.z : min.z;\n          this.closestPointToPoint(point2, point1);\n\n          var _dist = point2.distanceToSquared(point1);\n\n          if (_dist < closestDistanceSq) {\n            closestDistanceSq = _dist;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(point2);\n            if (_dist < threshold2) return Math.sqrt(_dist);\n          }\n        }\n      }\n    }\n\n    for (var _i5 = 0; _i5 < 12; _i5++) {\n      var l1 = segments1[_i5];\n\n      for (var _i6 = 0; _i6 < 12; _i6++) {\n        var l2 = segments2[_i6];\n        closestPointsSegmentToSegment(l1, l2, point1, point2);\n\n        var _dist2 = point1.distanceToSquared(point2);\n\n        if (_dist2 < closestDistanceSq) {\n          closestDistanceSq = _dist2;\n          if (target1) target1.copy(point1);\n          if (target2) target2.copy(point2);\n          if (_dist2 < threshold2) return Math.sqrt(_dist2);\n        }\n      }\n    }\n\n    return Math.sqrt(closestDistanceSq);\n  };\n}();","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/Utils/OrientedBox.js"],"names":["Box3","Vector3","Matrix4","Sphere","Line3","SeparatingAxisBounds","SeparatingAxisTriangle","closestPointsSegmentToSegment","OrientedBox","args","isOrientedBox","matrix","invMatrix","points","Array","fill","map","satAxes","satBounds","alignedSatBounds","sphere","min","max","other","copy","prototype","update","x","y","z","i","v","applyMatrix4","setFromPoints","minVec","axis","sb","index","pi","subVectors","setFromPointsField","invert","intersectsBox","aabbBounds","box","intersectsSphere","isSeparated","setFromBox","intersectsTriangle","saTri","pointsArr","cachedSatBounds","cachedSatBounds2","cachedAxis","triangle","isSeparatingAxisTriangle","needsUpdate","a","b","c","sa","triSatBounds","triSatAxes","sa1","i2","sa2","crossVectors","closestPointToPoint","point","target1","clamp","distanceToPoint","target","distanceTo","distanceToBox","xyzFields","segments1","segments2","point1","point2","threshold","target2","getCenter","threshold2","closestDistanceSq","Infinity","p","dist","distanceToSquared","Math","sqrt","count","i1","nextIndex","nextIndex2","index2","p1","p2","line1","set","f1","f2","f3","line2","start","end","l1","l2"],"mappings":"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","sourcesContent":["import { Box3, Vector3, Matrix4, Sphere, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { SeparatingAxisTriangle } from './SeparatingAxisTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox extends Box3 {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.sphere = new Sphere();\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tsuper.set( min, max );\n\t\tthis.matrix = matrix;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.matrix.copy( other.matrix );\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.sphere.setFromPoints( this.points );\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\tif ( ! box.intersectsSphere( this.sphere ) ) return false;\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new SeparatingAxisTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( ! triangle.isSeparatingAxisTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n"]},"metadata":{},"sourceType":"module"}