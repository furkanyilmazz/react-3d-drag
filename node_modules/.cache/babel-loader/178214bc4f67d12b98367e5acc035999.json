{"ast":null,"code":"import _classCallCheck from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Box3, Vector3 } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nvar box1 = new Box3();\nvar box2 = new Box3();\nvar vec = new Vector3();\nexport var MeshBVHDebug = /*#__PURE__*/function () {\n  function MeshBVHDebug(bvh, geometry) {\n    _classCallCheck(this, MeshBVHDebug);\n\n    this.bvh = bvh;\n    this.geometry = geometry;\n  } // Returns a simple, human readable object that represents the BVH.\n\n\n  _createClass(MeshBVHDebug, [{\n    key: \"getJSONStructure\",\n    value: function getJSONStructure() {\n      var bvh = this.bvh;\n      var depthStack = [];\n      bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n        var info = {\n          bounds: arrayToBox(boundingData, new Box3())\n        };\n\n        if (isLeaf) {\n          info.count = count;\n          info.offset = offset;\n        } else {\n          info.left = null;\n          info.right = null;\n        }\n\n        depthStack[depth] = info; // traversal hits the left then right node\n\n        var parent = depthStack[depth - 1];\n\n        if (parent) {\n          if (parent.left === null) {\n            parent.left = info;\n          } else {\n            parent.right = info;\n          }\n        }\n      });\n      return depthStack[0];\n    }\n  }, {\n    key: \"validateBounds\",\n    value: function validateBounds() {\n      var bvh = this.bvh,\n          geometry = this.geometry;\n      var depthStack = [];\n      var index = geometry.index;\n      var position = geometry.getAttribute('position');\n      var passes = true;\n      bvh.traverse(function (depth, isLeaf, boundingData, offset, count) {\n        var info = {\n          depth: depth,\n          isLeaf: isLeaf,\n          boundingData: boundingData,\n          offset: offset,\n          count: count\n        };\n        depthStack[depth] = info;\n        arrayToBox(boundingData, box1);\n        var parent = depthStack[depth - 1];\n\n        if (isLeaf) {\n          // check triangles\n          for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n            var i0 = index.getX(i);\n            var i1 = index.getX(i + 1);\n            var i2 = index.getX(i + 2);\n            var isContained = void 0;\n            vec.fromBufferAttribute(position, i0);\n            isContained = box1.containsPoint(vec);\n            vec.fromBufferAttribute(position, i1);\n            isContained = isContained && box1.containsPoint(vec);\n            vec.fromBufferAttribute(position, i2);\n            isContained = isContained && box1.containsPoint(vec);\n            console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n            passes = passes && isContained;\n          }\n        }\n\n        if (parent) {\n          // check if my bounds fit in my parents\n          arrayToBox(boundingData, box2);\n\n          var _isContained = box2.containsBox(box1);\n\n          console.assert(_isContained, 'Parent bounds does not fully contain child.');\n          passes = passes && _isContained;\n        }\n      });\n      return passes;\n    }\n  }]);\n\n  return MeshBVHDebug;\n}();","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/MeshBVHDebug.js"],"names":["Box3","Vector3","arrayToBox","box1","box2","vec","MeshBVHDebug","bvh","geometry","depthStack","traverse","depth","isLeaf","boundingData","offset","count","info","bounds","left","right","parent","index","position","getAttribute","passes","i","l","i0","getX","i1","i2","isContained","fromBufferAttribute","containsPoint","console","assert","containsBox"],"mappings":"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","sourcesContent":["import { Box3, Vector3 } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nconst box1 = new Box3();\r\nconst box2 = new Box3();\r\nconst vec = new Vector3();\r\n\r\nexport class MeshBVHDebug {\r\n\r\n\tconstructor( bvh, geometry ) {\r\n\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\t// Returns a simple, human readable object that represents the BVH.\r\n\tgetJSONStructure() {\r\n\r\n\t\tconst { bvh } = this;\r\n\t\tconst depthStack = [];\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tbounds: arrayToBox( boundingData, new Box3() ),\r\n\t\t\t};\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tinfo.count = count;\r\n\t\t\t\tinfo.offset = offset;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinfo.left = null;\r\n\t\t\t\tinfo.right = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\t// traversal hits the left then right node\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\t\tparent.left = info;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tparent.right = info;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn depthStack[ 0 ];\r\n\r\n\t}\r\n\r\n\tvalidateBounds() {\r\n\r\n\t\tconst { bvh, geometry } = this;\r\n\t\tconst depthStack = [];\r\n\t\tconst index = geometry.index;\r\n\t\tconst position = geometry.getAttribute( 'position' );\r\n\t\tlet passes = true;\r\n\r\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tdepth,\r\n\t\t\t\tisLeaf,\r\n\t\t\t\tboundingData,\r\n\t\t\t\toffset,\r\n\t\t\t\tcount,\r\n\t\t\t};\r\n\t\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t\tarrayToBox( boundingData, box1 );\r\n\t\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t// check triangles\r\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\tconst i0 = index.getX( i );\r\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\r\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\r\n\r\n\t\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i0 );\r\n\t\t\t\t\tisContained = box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i1 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tvec.fromBufferAttribute( position, i2 );\r\n\t\t\t\t\tisContained = isContained && box1.containsPoint( vec );\r\n\r\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\t// check if my bounds fit in my parents\r\n\t\t\t\tarrayToBox( boundingData, box2 );\r\n\r\n\t\t\t\tconst isContained = box2.containsBox( box1 );\r\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn passes;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}