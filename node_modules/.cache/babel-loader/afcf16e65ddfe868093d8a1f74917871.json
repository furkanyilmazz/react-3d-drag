{"ast":null,"code":"import { Ray, Matrix4, Mesh } from 'three';\nimport MeshBVH from './MeshBVH.js';\nimport Visualizer from './MeshBVHVisualizer.js';\nimport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './Constants.js';\nimport { getBVHExtremes, estimateMemoryInBytes } from './Utils/Debug.js';\nimport { MeshBVHDebug } from './MeshBVHDebug.js';\nconst ray = new Ray();\nconst tmpInverseMatrix = new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nfunction acceleratedRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n\n    if (raycaster.firstHitOnly === true) {\n      const res = this.geometry.boundsTree.raycastFirst(this, raycaster, ray);\n      if (res) intersects.push(res);\n    } else {\n      this.geometry.boundsTree.raycast(this, raycaster, ray, intersects);\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\n\nfunction computeBoundsTree(options) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\n\nfunction disposeBoundsTree() {\n  this.boundsTree = null;\n}\n\nexport { MeshBVH, Visualizer, Visualizer as MeshBVHVisualizer, MeshBVHDebug, acceleratedRaycast, computeBoundsTree, disposeBoundsTree, CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED, estimateMemoryInBytes, getBVHExtremes };","map":{"version":3,"sources":["/Users/a2017/Documents/GitHub/react-3d-drag/node_modules/three-mesh-bvh/src/index.js"],"names":["Ray","Matrix4","Mesh","MeshBVH","Visualizer","CENTER","AVERAGE","SAH","NOT_INTERSECTED","INTERSECTED","CONTAINED","getBVHExtremes","estimateMemoryInBytes","MeshBVHDebug","ray","tmpInverseMatrix","origMeshRaycastFunc","prototype","raycast","acceleratedRaycast","raycaster","intersects","geometry","boundsTree","material","undefined","copy","matrixWorld","invert","applyMatrix4","firstHitOnly","res","raycastFirst","push","call","computeBoundsTree","options","disposeBoundsTree","MeshBVHVisualizer"],"mappings":"AAAA,SAASA,GAAT,EAAcC,OAAd,EAAuBC,IAAvB,QAAmC,OAAnC;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,UAAP,MAAuB,wBAAvB;AACA,SAASC,MAAT,EAAiBC,OAAjB,EAA0BC,GAA1B,EAA+BC,eAA/B,EAAgDC,WAAhD,EAA6DC,SAA7D,QAA8E,gBAA9E;AACA,SAASC,cAAT,EAAyBC,qBAAzB,QAAsD,kBAAtD;AACA,SAASC,YAAT,QAA6B,mBAA7B;AAEA,MAAMC,GAAG,GAAG,IAAId,GAAJ,EAAZ;AACA,MAAMe,gBAAgB,GAAG,IAAId,OAAJ,EAAzB;AACA,MAAMe,mBAAmB,GAAGd,IAAI,CAACe,SAAL,CAAeC,OAA3C;;AAEA,SAASC,kBAAT,CAA6BC,SAA7B,EAAwCC,UAAxC,EAAqD;AAEpD,MAAK,KAAKC,QAAL,CAAcC,UAAnB,EAAgC;AAE/B,QAAK,KAAKC,QAAL,KAAkBC,SAAvB,EAAmC;AAEnCV,IAAAA,gBAAgB,CAACW,IAAjB,CAAuB,KAAKC,WAA5B,EAA0CC,MAA1C;AACAd,IAAAA,GAAG,CAACY,IAAJ,CAAUN,SAAS,CAACN,GAApB,EAA0Be,YAA1B,CAAwCd,gBAAxC;;AAEA,QAAKK,SAAS,CAACU,YAAV,KAA2B,IAAhC,EAAuC;AAEtC,YAAMC,GAAG,GAAG,KAAKT,QAAL,CAAcC,UAAd,CAAyBS,YAAzB,CAAuC,IAAvC,EAA6CZ,SAA7C,EAAwDN,GAAxD,CAAZ;AACA,UAAKiB,GAAL,EAAWV,UAAU,CAACY,IAAX,CAAiBF,GAAjB;AAEX,KALD,MAKO;AAEN,WAAKT,QAAL,CAAcC,UAAd,CAAyBL,OAAzB,CAAkC,IAAlC,EAAwCE,SAAxC,EAAmDN,GAAnD,EAAwDO,UAAxD;AAEA;AAED,GAlBD,MAkBO;AAENL,IAAAA,mBAAmB,CAACkB,IAApB,CAA0B,IAA1B,EAAgCd,SAAhC,EAA2CC,UAA3C;AAEA;AAED;;AAED,SAASc,iBAAT,CAA4BC,OAA5B,EAAsC;AAErC,OAAKb,UAAL,GAAkB,IAAIpB,OAAJ,CAAa,IAAb,EAAmBiC,OAAnB,CAAlB;AACA,SAAO,KAAKb,UAAZ;AAEA;;AAED,SAASc,iBAAT,GAA6B;AAE5B,OAAKd,UAAL,GAAkB,IAAlB;AAEA;;AAED,SACCpB,OADD,EACUC,UADV,EACsBA,UAAU,IAAIkC,iBADpC,EACuDzB,YADvD,EAECM,kBAFD,EAEqBgB,iBAFrB,EAEwCE,iBAFxC,EAGChC,MAHD,EAGSC,OAHT,EAGkBC,GAHlB,EAGuBC,eAHvB,EAGwCC,WAHxC,EAGqDC,SAHrD,EAICE,qBAJD,EAIwBD,cAJxB","sourcesContent":["import { Ray, Matrix4, Mesh } from 'three';\r\nimport MeshBVH from './MeshBVH.js';\r\nimport Visualizer from './MeshBVHVisualizer.js';\r\nimport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './Constants.js';\r\nimport { getBVHExtremes, estimateMemoryInBytes } from './Utils/Debug.js';\r\nimport { MeshBVHDebug } from './MeshBVHDebug.js';\r\n\r\nconst ray = new Ray();\r\nconst tmpInverseMatrix = new Matrix4();\r\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\r\n\r\nfunction acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst res = this.geometry.boundsTree.raycastFirst( this, raycaster, ray );\r\n\t\t\tif ( res ) intersects.push( res );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.geometry.boundsTree.raycast( this, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nfunction disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n\r\nexport {\r\n\tMeshBVH, Visualizer, Visualizer as MeshBVHVisualizer, MeshBVHDebug,\r\n\tacceleratedRaycast, computeBoundsTree, disposeBoundsTree,\r\n\tCENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED,\r\n\testimateMemoryInBytes, getBVHExtremes\r\n};\r\n"]},"metadata":{},"sourceType":"module"}